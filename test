diff --git a/samples/bluetooth/Routing_Projects/Tx/src/main.c b/samples/bluetooth/Routing_Projects/Tx/src/main.c
index 90d9c5c..e2daee5 100644
--- a/samples/bluetooth/Routing_Projects/Tx/src/main.c
+++ b/samples/bluetooth/Routing_Projects/Tx/src/main.c
@@ -46,19 +46,15 @@
 #include <bluetooth/l2cap.h>
 #include <bluetooth/hci.h>
 #include <bluetooth/mesh.h>
-#include </home/ahmed/zephyr/subsys/bluetooth/host/crypto.h>
-#include </home/ahmed/zephyr/subsys/bluetooth/host/mesh/adv.h>
-#include </home/ahmed/zephyr/subsys/bluetooth/host/mesh/mesh.h>
-#include </home/ahmed/zephyr/subsys/bluetooth/host/mesh/net.h>
-#include </home/ahmed/zephyr/subsys/bluetooth/host/mesh/transport.h>
-#include </home/ahmed/zephyr/subsys/bluetooth/host/mesh/access.h>
-#include </home/ahmed/zephyr/subsys/bluetooth/host/mesh/foundation.h>
 #include <stdio.h>
 
 #include <board.h>
 
+#include </home/reham/Zephyr/zephyr-hb/subsys/bluetooth/host/mesh/aodv_control_messages.h>
+#include </home/reham/Zephyr/zephyr-hb/subsys/bluetooth/host/mesh/routing_table.h>
+
 #define CID_INTEL 0x0002 /*Company identifier assigned by the Bluetooth SIG*/
-#define NODE_ADDR 0x0baf /*Unicast Address*/
+#define NODE_ADDR 0x0005 /*Unicast Address*/
 #define GROUP_ADDR 0xc000 /*The Address to use for pub and sub*/
 
 /*
@@ -147,6 +143,7 @@ static struct bt_mesh_cfg_srv cfg_srv = {
 	/* 3 transmissions with 20ms interval */
 	.net_transmit = BT_MESH_TRANSMIT(2, 20),
 	.relay_retransmit = BT_MESH_TRANSMIT(2, 20),
+
 };
 
 /*
@@ -628,6 +625,49 @@ static const struct bt_mesh_prov prov = {
 /*
  * Bluetooth Ready Callback
  */
+void set_tables()
+{
+	struct bt_mesh_route_entry  temp_entry;
+	struct bt_mesh_route_entry  *entry=&temp_entry;
+	bt_mesh_create_entry_valid(&entry);
+	entry->source_address =  0x000d;
+	entry->destination_address=0x0001;
+	entry->destination_sequence_number=0;
+	entry->next_hop=0x0001;
+	entry->source_number_of_elements=4;
+	entry->destination_number_of_elements=4;
+	entry->hop_count=1;
+	entry->net_idx=net_idx;
+	view_valid_list();
+	struct bt_mesh_route_entry  temp_entry2;
+	struct bt_mesh_route_entry  *entry2=&temp_entry2;
+	bt_mesh_create_entry_valid(&entry2);
+	entry2->source_address =  0x0001;
+	entry2->destination_address=0x000d;
+	entry2->destination_sequence_number=0;
+	entry2->next_hop=0x0009;
+	entry2->source_number_of_elements=4;
+	entry2->destination_number_of_elements=4;
+	entry2->hop_count=1;
+	entry2->net_idx=net_idx;
+	view_valid_list();
+
+
+	struct hello_msg_list_entry  temp_entry_hello;
+	struct hello_msg_list_entry  *entry_hello=&temp_entry_hello;
+	hello_msg_list_create_entry(&entry_hello);
+	entry_hello->source_address=0x0001;
+	entry_hello->net_idx=net_idx;
+
+	struct hello_msg_list_entry  temp_entry_hello2;
+	struct hello_msg_list_entry  *entry_hello2=&temp_entry_hello2;
+	hello_msg_list_create_entry(&entry_hello2);
+	entry_hello2->source_address=0x0009;
+	entry_hello2->net_idx=net_idx;
+
+	view_hello_msg_list();
+}
+
 
  static void configure(void)
  {
@@ -648,7 +688,7 @@ static const struct bt_mesh_prov prov = {
 
 	 /* Add Publication, Sw1 (ELEM 1) is Publishing to GROUP_ADDR */
 	 struct bt_mesh_cfg_mod_pub pub = {
-		 .addr=0x0E0E, /*change this to the intendded unicast/multicast*/
+		 .addr=0x0baf, /*change this to the intendded unicast/multicast*/
 		 .app_idx=app_idx,
 		 .ttl=0x07,
 	   .transmit=BT_MESH_TRANSMIT(3, 20),
@@ -656,6 +696,7 @@ static const struct bt_mesh_prov prov = {
   bt_mesh_cfg_mod_pub_set(net_idx, addr, addr ,BT_MESH_MODEL_ID_GEN_ONOFF_CLI, &pub, NULL);
 
  	printk("Configuration complete\n");
+ 	set_tables();
  }
 
 
diff --git a/samples/bluetooth/Routing_Projects/Tx2/CMakeLists.txt b/samples/bluetooth/Routing_Projects/Tx2/CMakeLists.txt
deleted file mode 100644
index f3bfd8f..0000000
--- a/samples/bluetooth/Routing_Projects/Tx2/CMakeLists.txt
+++ /dev/null
@@ -1,6 +0,0 @@
-set(QEMU_EXTRA_FLAGS -s)
-
-include($ENV{ZEPHYR_BASE}/cmake/app/boilerplate.cmake NO_POLICY_SCOPE)
-project(NONE)
-
-target_sources(app PRIVATE src/main.c)
diff --git a/samples/bluetooth/Routing_Projects/Tx2/README.rst b/samples/bluetooth/Routing_Projects/Tx2/README.rst
deleted file mode 100644
index 4a32d07..0000000
--- a/samples/bluetooth/Routing_Projects/Tx2/README.rst
+++ /dev/null
@@ -1,101 +0,0 @@
-.. _bluetooth-mesh-onoff-sample:
-
-Bluetooth: Mesh OnOff Model
-###########################
-
-Overview
-********
-
-This is a simple application demonstrating a Bluetooth mesh multi-element node.
-Each element has a mesh onoff client and server
-model which controls one of the 4 sets of buttons and LEDs .
-
-Prior to provisioning, an unprovisioned beacon is broadcast that contains
-a unique UUID. It is obtained from the device address set by Nordic in the
-FICR. Each button controls the state of its
-corresponding LED and does not initiate any mesh activity.
-
-The models for button 1 and LED 1 are in the node's root element.
-The 3 remaining button/LED pairs are in elements 1 through 3.
-Assuming the provisioner assigns 0x100 to the root element,
-the secondary elements will appear at 0x101, 0x102 and 0x103.
-
-After provisioning, the button clients must
-be configured to publish and the LED servers to subscribe.
-
-If a LED server is provided with a publish address, it will
-also publish its status on an onoff state change.
-
-If a button is pressed only once within a 1 second interval, it sends an
-"on" message. If it is pressed more than once, it
-sends an "off" message. The buttons are quite noisy and are debounced in
-the button_pressed() interrupt handler. An interrupt within 250ms of the
-previous is discarded. This might seem a little clumsy, but the alternative of
-using one button for "on" and another for "off" would reduce the number
-of onoff clients from 4 to 2.
-
-Requirements
-************
-
-This sample has been tested on the Nordic nRF52840-PDK board, but would
-likely also run on the nrf52_pca10040 board.
-
-Building and Running
-********************
-
-This sample can be found under :file:`samples/boards/nrf52/mesh/onoff-app` in the
-Zephyr tree.
-
-The following commands build the application.
-
-.. zephyr-app-commands::
-   :zephyr-app: samples/boards/nrf52/mesh/onoff-app
-   :board: nrf52840_pca10056
-   :goals: build flash
-   :compact:
-
-Prior to provisioning, each button controls its corresponding LED as one
-would expect with an actual switch.
-
-Provisioning is done using the BlueZ meshctl utility. Below is an example that
-binds button 2 and LED 1 to application key 1. It then configures button 2
-to publish to group 0xc000 and LED 1 to subscribe to that group.
-
-.. code-block:: console
-
-   discover-unprovisioned on
-   provision <discovered UUID>
-   menu config
-   target 0100
-   appkey-add 1
-   bind 0 1 1000                # bind appkey 1 to LED server on element 0 (unicast 0100)
-   sub-add 0100 c000 1000       # add subscription to group address c000 to the LED server
-   bind 1 1 1001                # bind appkey 1 to button 2 on element 1 (unicast 0101)
-   pub-set 0101 c000 1 0 0 1001 # publish button 2 to group address c000
-
-The meshctl utility maintains a persistent JSON database containing
-the mesh configuration. As additional nodes (boards) are provisioned, it
-assigns sequential unicast addresses based on the number of elements
-supported by the node. This example supports 4 elements per node.
-
-The first or root element of the node contains models for configuration,
-health, and onoff. The secondary elements only
-have models for onoff. The meshctl target for configuration must be the
-root element's unicast address as it is the only one that has a
-configuration server model.
-
-If meshctl is gracefully exited, it can be restarted and reconnected to
-network 0x0. The board configuration is volatile and if the board is reset,
-power cycled, or reprogrammed, it will have to be provisioned and configured
-again.
-
-The meshctl utility also supports a onoff model client that can be used to
-change the state of any LED that is bound to application key 0x1.
-This is done by setting the target to the unicast address of the element
-that has that LED's model and issuing the onoff command.
-Group addresses are not supported.
-
-This application was derived from the sample mesh skeleton at
-:file:`samples/bluetooth/mesh`.
-
-See :ref:`bluetooth setup section <bluetooth_setup>` for details.
diff --git a/samples/bluetooth/Routing_Projects/Tx2/prj.conf b/samples/bluetooth/Routing_Projects/Tx2/prj.conf
deleted file mode 100644
index 30816ba..0000000
--- a/samples/bluetooth/Routing_Projects/Tx2/prj.conf
+++ /dev/null
@@ -1,103 +0,0 @@
-#CONFIG_INIT_STACKS=y      # if set, lots of noise from mesh/adv.c: STACK_ANALYZE
-CONFIG_MAIN_STACK_SIZE=512
-CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=2048
-
-CONFIG_BOOT_BANNER=y
-CONFIG_BUILD_TIMESTAMP=y
-
-CONFIG_BT_OBSERVER=y
-CONFIG_BT_BROADCASTER=y
-CONFIG_BT_CTLR_DUP_FILTER_LEN=0
-CONFIG_BT_CTLR_LE_ENC=n
-CONFIG_BT_CTLR_LE_PING=n
-CONFIG_BT_CTLR_DATA_LENGTH=n
-CONFIG_BT_CTLR_PHY=n
-CONFIG_BT_CTLR_CHAN_SEL_2=n
-CONFIG_BT_CTLR_MIN_USED_CHAN=n
-CONFIG_BT_CTLR_ADV_EXT=n
-CONFIG_BT_CTLR_PRIVACY=n
-
-CONFIG_BT_PERIPHERAL=y
-
-CONFIG_BT=y
-CONFIG_BT_TINYCRYPT_ECC=y
-CONFIG_BT_RX_BUF_COUNT=30
-CONFIG_BT_L2CAP_RX_MTU=69
-CONFIG_BT_L2CAP_TX_MTU=69
-CONFIG_BT_L2CAP_TX_BUF_COUNT=8
-
-CONFIG_BT_MESH=y
-CONFIG_BT_MESH_RELAY=y
-CONFIG_BT_MESH_LOW_POWER=n
-CONFIG_BT_MESH_FRIEND=n
-CONFIG_BT_MESH_FRIEND_QUEUE_SIZE=16
-CONFIG_BT_MESH_ADV_BUF_COUNT=20
-
-CONFIG_BT_MESH_PB_GATT=y
-CONFIG_BT_MESH_PB_ADV=y
-CONFIG_BT_MESH_GATT_PROXY=y
-CONFIG_BT_MESH_CFG_CLI=y
-
-#CONFIG_BT_MESH_LPN_SCAN_LATENCY=30
-#CONFIG_BT_MESH_LPN_RECV_DELAY=40
-#CONFIG_BT_MESH_LPN_POLL_TIMEOUT=300
-
-CONFIG_BT_MESH_SUBNET_COUNT=2
-CONFIG_BT_MESH_APP_KEY_COUNT=2
-CONFIG_BT_MESH_MODEL_KEY_COUNT=2
-CONFIG_BT_MESH_MODEL_GROUP_COUNT=2
-CONFIG_BT_MESH_LABEL_COUNT=3
-
-#CONFIG_BT_MESH_IV_UPDATE_TEST=y
-
-CONFIG_UART_CONSOLE=y
-
-# this outputs btmon formatted data to the serial port
-#CONFIG_BT_DEBUG_MONITOR=y
-
-#CONFIG_SYS_LOG=y
-CONFIG_SYS_LOG_DEFAULT_LEVEL=4
-CONFIG_SYS_LOG_EXT_HOOK=y
-CONFIG_BT_DEBUG_LOG=y
-CONFIG_BT_MESH_TX_SEG_MSG_COUNT=4
-CONFIG_BT_MESH_DEBUG=y
-#CONFIG_BT_MESH_DEBUG_PROV=y
-#CONFIG_BT_MESH_DEBUG_PROXY=y
-#CONFIG_BT_MESH_DEBUG_BEACON=y
-#CONFIG_BT_MESH_DEBUG_NET=n
-#CONFIG_BT_MESH_DEBUG_TRANS=n
-#CONFIG_BT_MESH_DEBUG_ROUTING=y
-#CONFIG_BT_MESH_DEBUG_LOW_POWER=y
-#CONFIG_BT_MESH_DEBUG_FRIEND=y
-#CONFIG_BT_MESH_DEBUG_MODEL=y
-#CONFIG_BT_MESH_DEBUG_ACCESS=y
-#CONFIG_BT_MESH_DEBUG_CRYPTO=y
-#CONFIG_BT_MESH_DEBUG_ADV=y
-#CONFIG_BT_MESH_SELF_TEST=y
-
-#CONFIG_BT_HCI_VS_EXT=n
-
-#CONFIG_STACK_USAGE=y
-
-CONFIG_BT_RX_STACK_SIZE=4096
-
-#CONFIG_BT_DEBUG_HCI_DRIVER=y
-#CONFIG_BT_DEBUG_HCI_CORE=y
-#CONFIG_BT_DEBUG_GATT=y
-#CONFIG_BT_DEBUG_CONN=y
-
-CONFIG_BT_MAX_CONN=1
-CONFIG_BT_CTLR_RX_BUFFERS=6
-CONFIG_BT_CTLR_TX_BUFFERS=4
-CONFIG_BT_HCI_CMD_COUNT=4
-
-CONFIG_BT_ATT_PREPARE_COUNT=2
-
-#CONFIG_NET_BUF_SIMPLE_LOG=y
-#CONFIG_SYS_LOG_NET_BUF_LEVEL=4
-#CONFIG_NET_BUF_LOG=y
-#CONFIG_BT_CTLR_DEBUG_PINS=y
-
-
-# ROUTING CONFIGURATION PARAMETERS
-CONFIG_BT_MESH_ROUTING=y
diff --git a/samples/bluetooth/Routing_Projects/Tx2/sample.yaml b/samples/bluetooth/Routing_Projects/Tx2/sample.yaml
deleted file mode 100644
index edf07a9..0000000
--- a/samples/bluetooth/Routing_Projects/Tx2/sample.yaml
+++ /dev/null
@@ -1,6 +0,0 @@
-sample:
-  name: Bluetooth Mesh
-tests:
-  test:
-    platform_whitelist: nrf52840_pca10056
-    tags: bluetooth
diff --git a/samples/bluetooth/Routing_Projects/Tx2/src/main.c b/samples/bluetooth/Routing_Projects/Tx2/src/main.c
deleted file mode 100644
index 740bce7..0000000
--- a/samples/bluetooth/Routing_Projects/Tx2/src/main.c
+++ /dev/null
@@ -1,783 +0,0 @@
-/* main.c - Application main entry point */
-
-/*
- * Copyright (c) 2017 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-/*
- * This application is specific to the Nordic nRF52840-PDK board.
- * Acts as a server node
- * It supports the 4 buttons and 4 LEDs as mesh clients and servers.
- *
- * Prior to provisioning, a button inverts the state of the
- * corresponding LED.
- *
- * The unprovisioned beacon uses the device address set by Nordic
- * in the FICR as its UUID and is presumed unique.
- *
- * Button and LED 1 are in the root node.
- * The 3 remaining button/LED pairs are in element 1 through 3.
- * Assuming the provisioner assigns 0x100 to the root node,
- * the secondary elements will appear at 0x101, 0x102 and 0x103.
- *
- * It's anticipated that after provisioning, the button clients would
- * be configured to publish and the LED servers to subscribe.
- *
- * If a LED server is provided with a publish address, it will
- * also publish its status on a state change.
- *
- * Messages from a button to its corresponding LED are ignored as
- * the LED's state has already been changed locally by the button client.
- *
- * The buttons are debounced at a nominal 250ms. That value can be
- * changed as needed.
- *
- */
-
-#include <misc/printk.h>
-#include <misc/byteorder.h>
-#include <nrf.h>
-#include <device.h>
-#include <gpio.h>
-#include <bluetooth/bluetooth.h>
-#include <bluetooth/conn.h>
-#include <bluetooth/l2cap.h>
-#include <bluetooth/hci.h>
-#include <bluetooth/mesh.h>
-#include </home/ahmed/zephyr/subsys/bluetooth/host/crypto.h>
-#include </home/ahmed/zephyr/subsys/bluetooth/host/mesh/adv.h>
-#include </home/ahmed/zephyr/subsys/bluetooth/host/mesh/mesh.h>
-#include </home/ahmed/zephyr/subsys/bluetooth/host/mesh/net.h>
-#include </home/ahmed/zephyr/subsys/bluetooth/host/mesh/transport.h>
-#include </home/ahmed/zephyr/subsys/bluetooth/host/mesh/access.h>
-#include </home/ahmed/zephyr/subsys/bluetooth/host/mesh/foundation.h>
-#include <stdio.h>
-
-#include <board.h>
-
-#define CID_INTEL 0x0002 /*Company identifier assigned by the Bluetooth SIG*/
-#define NODE_ADDR 0x0e0e /*Unicast Address*/
-#define GROUP_ADDR 0xc000 /*The Address to use for pub and sub*/
-
-/*
- * The include must follow the define for it to take effect.
- * If it isn't, the domain defaults to "general"
- */
-/* Logging and Debugging */
-#define SYS_LOG_DOMAIN "OnOff"
-#include <logging/sys_log.h>
-
-struct sdu {
-u32_t data1;
-u32_t data2;
-u32_t data3;
-u32_t data4;
-u32_t data5;
-};
-
-
-/*For Provisioning and Configurations*/
-
-static const u8_t net_key[16] = {
-	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
-	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
-};
-static const u8_t dev_key[16] = {
-	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
-	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
-};
-static const u8_t app_key[16] = {
-	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
-	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
-};
-
-static const u16_t net_idx;
-static const u16_t app_idx;
-static const u32_t iv_index;
-static u8_t flags;
-static u16_t addr = NODE_ADDR;
-static u32_t seq;
-
-/* Model Operation Codes */
-/* Returns the opcode for each message, 0x82 0x01 is the opcode for the Generic OnOff Get
- 	 Mesh_Model_Specification v1.0 page 298 */
-#define BT_MESH_MODEL_OP_GEN_ONOFF_GET		BT_MESH_MODEL_OP_2(0x82, 0x01)
-#define BT_MESH_MODEL_OP_GEN_ONOFF_SET		BT_MESH_MODEL_OP_2(0x82, 0x02)
-#define BT_MESH_MODEL_OP_GEN_ONOFF_SET_UNACK	BT_MESH_MODEL_OP_2(0x82, 0x03)
-#define BT_MESH_MODEL_OP_GEN_ONOFF_STATUS	BT_MESH_MODEL_OP_2(0x82, 0x04)
-
-/*Message handler (The messages corresponding to the above opcodes))*/
-static void gen_onoff_set(struct bt_mesh_model *model, // Mesh Model instance (mesh/access.h line314)
-			  struct bt_mesh_msg_ctx *ctx,//Message sending context
-			  struct net_buf_simple *buf);//buffer
-
-static void gen_onoff_set_unack(struct bt_mesh_model *model,
-			  struct bt_mesh_msg_ctx *ctx,
-			  struct net_buf_simple *buf);
-
-static void gen_onoff_get(struct bt_mesh_model *model,
-			  struct bt_mesh_msg_ctx *ctx,
-			  struct net_buf_simple *buf);
-
-static void gen_onoff_status(struct bt_mesh_model *model,
-			  struct bt_mesh_msg_ctx *ctx,
-			  struct net_buf_simple *buf);
-
-/*
- * Server Configuration Declaration
- */
-/*Checks the fearures inside the server according to the Configuration file*/
-static struct bt_mesh_cfg_srv cfg_srv = {
-	.relay = BT_MESH_RELAY_DISABLED, // TODO: we modify this to enable
-	.beacon = BT_MESH_BEACON_ENABLED,
-	#if defined(CONFIG_BT_MESH_FRIEND)
-	.frnd = BT_MESH_FRIEND_ENABLED,
-	#else
-	.frnd = BT_MESH_FRIEND_NOT_SUPPORTED,
-	#endif
-	#if defined(CONFIG_BT_MESH_GATT_PROXY)
-	.gatt_proxy = BT_MESH_GATT_PROXY_ENABLED,
-	#else
-	.gatt_proxy = BT_MESH_GATT_PROXY_NOT_SUPPORTED,
-	#endif
-	.default_ttl = 7,
-
-	/* 3 transmissions with 20ms interval */
-	.net_transmit = BT_MESH_TRANSMIT(2, 20),
-	.relay_retransmit = BT_MESH_TRANSMIT(2, 20),
-};
-
-/*
- * Client Configuration Declaration
- */
-
-static struct bt_mesh_cfg_cli cfg_cli = {
-};
-
-/*
- * Health Server Declaration
- */
-
-static struct bt_mesh_health_srv health_srv = {
-};
-
-/*
- * Publication Declarations
- *
- * The publication messages are initialized to the
- * the size of the opcode + content
- *
- * For publication, the message must be in static or global as
- * it is re-transmitted several times. This occurs
- * after the function that called bt_mesh_model_publish() has
- * exited and the stack is no longer valid.
- *
- * Note that the additional 4 bytes for the AppMIC is not needed
- * because it is added to a stack variable at the time a
- * transmission occurs.
- *
- */
-
-BT_MESH_HEALTH_PUB_DEFINE(health_pub, 0);
-
-BT_MESH_MODEL_PUB_DEFINE(gen_onoff_pub_srv, NULL, 2 + 2);
-BT_MESH_MODEL_PUB_DEFINE(gen_onoff_pub_cli, NULL, 2 + 2);
-BT_MESH_MODEL_PUB_DEFINE(gen_onoff_pub_srv_s_0, NULL, 2 + 2);
-BT_MESH_MODEL_PUB_DEFINE(gen_onoff_pub_cli_s_0, NULL, 2 + 2);
-BT_MESH_MODEL_PUB_DEFINE(gen_onoff_pub_srv_s_1, NULL, 2 + 2);
-BT_MESH_MODEL_PUB_DEFINE(gen_onoff_pub_cli_s_1, NULL, 2 + 2);
-BT_MESH_MODEL_PUB_DEFINE(gen_onoff_pub_srv_s_2, NULL, 2 + 2);
-BT_MESH_MODEL_PUB_DEFINE(gen_onoff_pub_cli_s_2, NULL, 2 + 2);
-/*
- * Models in an element must have unique op codes.
- *
- * The mesh stack dispatches a message to the first model in an element
- * only one model in each element Rxs
- * that is also bound to an app key and supports the op code in the
- * received message.
- *
- */
-
-/*
- * OnOff Model Server Op Dispatch Table
- *
- */
-
- /*Three server msgs*/
- static const struct bt_mesh_model_op gen_onoff_srv_op[] = {
- 	{ BT_MESH_MODEL_OP_GEN_ONOFF_GET, 0, gen_onoff_get }, /*{opcode, Minimum required message length, Message handler for the opcode}*/
- 	{ BT_MESH_MODEL_OP_GEN_ONOFF_SET, 2, gen_onoff_set },
- 	{ BT_MESH_MODEL_OP_GEN_ONOFF_SET_UNACK, 2, gen_onoff_set_unack },
- 	BT_MESH_MODEL_OP_END,
- };
-
-/*
- * OnOff Model Client Op Dispatch Table
- */
-
-static const struct bt_mesh_model_op gen_onoff_cli_op[] = {
-	{ BT_MESH_MODEL_OP_GEN_ONOFF_STATUS, 1, gen_onoff_status },
-	BT_MESH_MODEL_OP_END,
-};
-
-struct onoff_state {
-	u8_t current;
-	u8_t previous;
-	u8_t led_gpio_pin;
-	struct device *led_device;
-};
-
-/*
- * Declare and Initialize Element Contexts
- * Change to select different GPIO output pins
- */
-
-static struct onoff_state onoff_state[] = {
-	{ .led_gpio_pin = LED0_GPIO_PIN },
-	{ .led_gpio_pin = LED1_GPIO_PIN },
-	{ .led_gpio_pin = LED2_GPIO_PIN },
-	{ .led_gpio_pin = LED3_GPIO_PIN },
-};
-
-/*
- *
- * Element Model Declarations
- *
- * Element 0 Root Models
- */
-
-static struct bt_mesh_model root_models[] = {
-	BT_MESH_MODEL_CFG_SRV(&cfg_srv),
-	BT_MESH_MODEL_CFG_CLI(&cfg_cli),
-	BT_MESH_MODEL_HEALTH_SRV(&health_srv, &health_pub),
-	BT_MESH_MODEL(BT_MESH_MODEL_ID_GEN_ONOFF_SRV, gen_onoff_srv_op,
-		      &gen_onoff_pub_srv, &onoff_state[0]),
-	BT_MESH_MODEL(BT_MESH_MODEL_ID_GEN_ONOFF_CLI, gen_onoff_cli_op,
-		      &gen_onoff_pub_cli, &onoff_state[0]),
-};
-
-/*
- * Element 1 Models
- */
-
-static struct bt_mesh_model secondary_0_models[] = {
-	BT_MESH_MODEL(BT_MESH_MODEL_ID_GEN_ONOFF_SRV, gen_onoff_srv_op,
-		      &gen_onoff_pub_srv_s_0, &onoff_state[1]),
-	BT_MESH_MODEL(BT_MESH_MODEL_ID_GEN_ONOFF_CLI, gen_onoff_cli_op,
-		      &gen_onoff_pub_cli_s_0, &onoff_state[1]),
-};
-
-/*
- * Element 2 Models
- */
-
-static struct bt_mesh_model secondary_1_models[] = {
-	BT_MESH_MODEL(BT_MESH_MODEL_ID_GEN_ONOFF_SRV, gen_onoff_srv_op,
-		      &gen_onoff_pub_srv_s_1, &onoff_state[2]),
-	BT_MESH_MODEL(BT_MESH_MODEL_ID_GEN_ONOFF_CLI, gen_onoff_cli_op,
-		      &gen_onoff_pub_cli_s_1, &onoff_state[2]),
-};
-
-/*
- * Element 3 Models
- */
-
-static struct bt_mesh_model secondary_2_models[] = {
-	BT_MESH_MODEL(BT_MESH_MODEL_ID_GEN_ONOFF_SRV, gen_onoff_srv_op,
-		      &gen_onoff_pub_srv_s_2, &onoff_state[3]),
-	BT_MESH_MODEL(BT_MESH_MODEL_ID_GEN_ONOFF_CLI, gen_onoff_cli_op,
-		      &gen_onoff_pub_cli_s_2, &onoff_state[3]),
-};
-
-/*
- * Button to Client Model Assignments
- */
- //The client is the button, which is model 4 in elem 0 and model 1 in elem 1 2 3
-struct bt_mesh_model *mod_cli_sw[] = {
-		&root_models[4],
-		&secondary_0_models[1],
-		&secondary_1_models[1],
-		&secondary_2_models[1],
-};
-
-/*
- * LED to Server Model Assigmnents
- */
-struct bt_mesh_model *mod_srv_sw[] = {
-		&root_models[3],
-		&secondary_0_models[0],
-		&secondary_1_models[0],
-		&secondary_2_models[0],
-};
-
-/*
- * Root and Secondary Element Declarations
- */
-
-static struct bt_mesh_elem elements[] = {
-	BT_MESH_ELEM(0, root_models, BT_MESH_MODEL_NONE),
-	BT_MESH_ELEM(0, secondary_0_models, BT_MESH_MODEL_NONE),
-	BT_MESH_ELEM(0, secondary_1_models, BT_MESH_MODEL_NONE),
-	BT_MESH_ELEM(0, secondary_2_models, BT_MESH_MODEL_NONE),
-};
-
-static const struct bt_mesh_comp comp = {
-	.cid = CID_INTEL,
-	.elem = elements,
-	.elem_count = ARRAY_SIZE(elements),
-};
-
-struct device *sw_device;
-
-struct sw {
-	u8_t sw_num;
-	u8_t onoff_state;
-	struct k_work button_work;
-	struct k_timer button_timer;
-};
-
-
-static u8_t button_press_cnt;
-static struct sw sw;
-
-static struct gpio_callback button_cb;
-
-static u8_t trans_id;
-static u32_t time, last_time;
-static u16_t primary_addr;
-static u16_t primary_net_idx;
-
-/*
- * Generic OnOff Model Server Message Handlers
- *
- * Mesh Model Specification 3.1.1
- *
- */
-
-static void gen_onoff_get(struct bt_mesh_model *model,
-			  struct bt_mesh_msg_ctx *ctx,
-			  struct net_buf_simple *buf)
-{
-	NET_BUF_SIMPLE_DEFINE(msg, 2 + 1 + 4);
-	struct onoff_state *onoff_state = model->user_data;
-
-	SYS_LOG_INF("addr 0x%04x onoff 0x%02x",
-		    model->elem->addr, onoff_state->current);
-	bt_mesh_model_msg_init(&msg, BT_MESH_MODEL_OP_GEN_ONOFF_STATUS);
-	net_buf_simple_add_u8(&msg, onoff_state->current);
-
-	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
-		SYS_LOG_ERR("Unable to send On Off Status response");
-	}
-}
-
-static void gen_onoff_set_unack(struct bt_mesh_model *model,
-				struct bt_mesh_msg_ctx *ctx,
-				struct net_buf_simple *buf)
-{
-	struct net_buf_simple *msg = model->pub->msg;
-	struct onoff_state *onoff_state = model->user_data;
-	int err;
-
-	onoff_state->current = net_buf_simple_pull_u8(buf);
-	SYS_LOG_INF("addr 0x%02x state 0x%02x",
-		    model->elem->addr, onoff_state->current);
-
-	/* Pin set low turns on LED's on the nrf52840-pca10056 board */
-	gpio_pin_write(onoff_state->led_device,
-		       onoff_state->led_gpio_pin,
-		       onoff_state->current ? 0 : 1);
-
-	/*
-	 * If a server has a publish address, it is required to
-	 * publish status on a state change
-	 *
-	 * See Mesh Profile Specification 3.7.6.1.2
-	 *
-	 * Only publish if there is an assigned address
-	 */
-
-	if (onoff_state->previous != onoff_state->current &&
-	    model->pub->addr != BT_MESH_ADDR_UNASSIGNED) {
-		SYS_LOG_INF("publish last 0x%02x cur 0x%02x",
-			    onoff_state->previous,
-			    onoff_state->current);
-		onoff_state->previous = onoff_state->current;
-		bt_mesh_model_msg_init(msg,
-				       BT_MESH_MODEL_OP_GEN_ONOFF_STATUS);
-		net_buf_simple_add_u8(msg, onoff_state->current);
-		err = bt_mesh_model_publish(model);
-		if (err) {
-			SYS_LOG_ERR("bt_mesh_model_publish err %d", err);
-		}
-	}
-}
-
-static void gen_onoff_set(struct bt_mesh_model *model,
-			  struct bt_mesh_msg_ctx *ctx,
-			  struct net_buf_simple *buf)
-{
-	SYS_LOG_INF("");
-
-	gen_onoff_set_unack(model, ctx, buf);
-	gen_onoff_get(model, ctx, buf);
-}
-
-static void gen_onoff_status(struct bt_mesh_model *model,
-			     struct bt_mesh_msg_ctx *ctx,
-			     struct net_buf_simple *buf)
-{
-	u8_t	state;
-
-	state = net_buf_simple_pull_u8(buf);
-
-	SYS_LOG_INF("Node 0x%04x OnOff status from 0x%04x with state 0x%02x",
-		    model->elem->addr, ctx->addr, state);
-}
-
-static int output_number(bt_mesh_output_action_t action, uint32_t number)
-{
-	SYS_LOG_INF("OOB Number %u", number);
-	return 0;
-}
-
-static int output_string(const char *str)
-{
-	SYS_LOG_INF("OOB String %s", str);
-	return 0;
-}
-
-static void prov_complete(u16_t net_idx, u16_t addr)
-{
-	SYS_LOG_INF("provisioning complete for net_idx 0x%04x addr 0x%04x",
-		    net_idx, addr);
-	primary_addr = addr;
-	primary_net_idx = net_idx;
-}
-
-static void prov_reset(void)
-{
-	bt_mesh_prov_enable(BT_MESH_PROV_ADV | BT_MESH_PROV_GATT);
-}
-
-static u8_t dev_uuid[16] = { 0xdd, 0xdd };
-
-#define BUTTON_DEBOUNCE_DELAY_MS 250
-
-/*
- * Map GPIO pins to button number
- * Change to select different GPIO input pins
- */
-
-static uint8_t pin_to_sw(uint32_t pin_pos)
-{
-	switch (pin_pos) {
-	case BIT(SW0_GPIO_PIN): return 0;
-	case BIT(SW1_GPIO_PIN): return 1;
-	case BIT(SW2_GPIO_PIN): return 2;
-	case BIT(SW3_GPIO_PIN): return 3;
-	}
-
-	SYS_LOG_ERR("No match for GPIO pin 0x%08x", pin_pos);
-	return 0;
-}
-
-static void button_pressed(struct device *dev, struct gpio_callback *cb,
-			   uint32_t pin_pos)
-{
-	/*
-	 * One button press within a 1 second interval sends an on message
-	 * More than one button press sends an off message
-	 */
-
-	time = k_uptime_get_32();
-
-	/* debounce the switch */
-	if (time < last_time + BUTTON_DEBOUNCE_DELAY_MS) {
-		last_time = time;
-		return;
-	}
-
-	if (button_press_cnt == 0) {
-		k_timer_start(&sw.button_timer, K_SECONDS(1), 0);
-	}
-
-	SYS_LOG_INF("button_press_cnt 0x%02x", button_press_cnt);
-	button_press_cnt++;
-
-	/* The variable pin_pos is the pin position in the GPIO register,
-	 * not the pin number. It's assumed that only one bit is set.
-	 */
-
-	sw.sw_num = pin_to_sw(pin_pos);
-	last_time = time;
-}
-
-/*
- * Button Count Timer Worker
- */
-
-static void button_cnt_timer(struct k_timer *work)
-{
-	struct sw *button_sw = CONTAINER_OF(work, struct sw, button_timer);
-
-	button_sw->onoff_state = button_press_cnt == 1 ? 1 : 0;
-	SYS_LOG_INF("button_press_cnt 0x%02x onoff_state 0x%02x",
-			button_press_cnt, button_sw->onoff_state);
-	button_press_cnt = 0;
-	k_work_submit(&sw.button_work);
-}
-
-/*
- * Button Pressed Worker Task
- */
-
-static void button_pressed_worker(struct k_work *work)
-{
-	struct bt_mesh_model *mod_cli, *mod_srv;
-	struct bt_mesh_model_pub *pub_cli, *pub_srv;
-	struct sw *sw = CONTAINER_OF(work, struct sw, button_work);
-	int err;
-	u8_t sw_idx = sw->sw_num;
-
-	mod_cli = mod_cli_sw[sw_idx];
-	pub_cli = mod_cli->pub;
-
-	mod_srv = mod_srv_sw[sw_idx];
-	pub_srv = mod_srv->pub;
-
-	/* If unprovisioned, just call the set function.
-	 * The intent is to have switch-like behavior
-	 * prior to provisioning. Once provisioned,
-	 * the button and its corresponding led are no longer
-	 * associated and act independently. So, if a button is to
-	 * control its associated led after provisioning, the button
-	 * must be configured to either publish to the led's unicast
-	 * address or a group to which the led is subscribed.
-	 */
-
-	if (primary_addr == BT_MESH_ADDR_UNASSIGNED) {
-		NET_BUF_SIMPLE_DEFINE(msg, 1);
-		struct bt_mesh_msg_ctx ctx = {
-			.addr = sw_idx + primary_addr,
-		};
-
-		/* This is a dummy message sufficient
-		 * for the led server
-		 */
-
-		net_buf_simple_add_u8(&msg, sw->onoff_state);
-		gen_onoff_set_unack(mod_srv, &ctx, &msg);
-		return;
-	}
-
-	if (pub_cli->addr == BT_MESH_ADDR_UNASSIGNED) {
-		return;
-	}
-
-	SYS_LOG_INF("publish to 0x%04x onoff 0x%04x sw_idx 0x%04x",
-		    pub_cli->addr, sw->onoff_state, sw_idx);
-	bt_mesh_model_msg_init(pub_cli->msg,
-			       BT_MESH_MODEL_OP_GEN_ONOFF_SET);
-	net_buf_simple_add_u8(pub_cli->msg, sw->onoff_state);
-	net_buf_simple_add_u8(pub_cli->msg, trans_id++);
-	err = bt_mesh_model_publish(mod_cli);
-	if (err) {
-		SYS_LOG_ERR("bt_mesh_model_publish err %d", err);
-	}
-
-	/*struct RREQ_data data = {
-		.source_address = 0x0b0c,
-		.destination_address = 0x0baf,
-		.next_hop = 0x9101,
-		.source_number_of_elements = 69,
-		.G=1,
-		.D=0,
-		.U=1,
-		.I=1,
-		.hop_count=128,
-		.source_sequence_number = 0x112233
-		//.destination_sequence_number = 0x445566
-	};
-		send_RREQ(&data,3,primary_net_idx*/
-
-	//bt_mesh_ctl_send(&tx, 0x0b, &message,sizeof(struct sdu), NULL, NULL, NULL);
-
-}
-
-/* Disable OOB security for SILabs Android app */
-
-static const struct bt_mesh_prov prov = {
-	.uuid = dev_uuid,
- #if 1
-	.output_size = 6,
-	.output_actions = (BT_MESH_DISPLAY_NUMBER | BT_MESH_DISPLAY_STRING),
-	.output_number = output_number,
-	.output_string = output_string,
- #else
-	.output_size = 0,
-	.output_actions = 0,
-	.output_number = 0,
- #endif
-	.complete = prov_complete,
-	.reset = prov_reset,
-};
-
-/*
- * Bluetooth Ready Callback
- */
-
- static void configure(void)
- {
- 	printk("Configuring...\n");
-
- 	/* Add Application Key */
- 	bt_mesh_cfg_app_key_add(net_idx, addr, net_idx, app_idx, app_key, NULL);
-
-	/*Bind the App key to BT_MESH_MODEL_ID_GEN_ONOFF_SRV (ONOFF Server Model) */
- 	bt_mesh_cfg_mod_app_bind(net_idx, addr, addr, app_idx, BT_MESH_MODEL_ID_GEN_ONOFF_SRV, NULL);
-	//printk("Binding complete");
-	/*Add Subscription, LED0 (ELEM 0) is Subscribing to GROUP_ADDR */
- 	//bt_mesh_cfg_mod_sub_add(net_idx, addr, addr, 0x0b11,
-  	//			    BT_MESH_MODEL_ID_GEN_ONOFF_SRV, NULL);
-	 //printk("Subscription complete");
-	 /*Bind the App key to BT_MESH_MODEL_ID_GEN_ONOFF_CLI (ONOFF Client Model)*/
-	 bt_mesh_cfg_mod_app_bind(net_idx, addr, addr, app_idx, BT_MESH_MODEL_ID_GEN_ONOFF_CLI, NULL);
-
-	 /* Add Publication, Sw1 (ELEM 1) is Publishing to GROUP_ADDR */
-	 struct bt_mesh_cfg_mod_pub pub = {
-		 .addr=0x0baf, /*change this to the intendded unicast/multicast*/
-		 .app_idx=app_idx,
-		 .ttl=0x07,
-	   .transmit=BT_MESH_TRANSMIT(3, 20),
-	 };//
-  bt_mesh_cfg_mod_pub_set(net_idx, addr, addr ,BT_MESH_MODEL_ID_GEN_ONOFF_CLI, &pub, NULL);
-
- 	printk("Configuration complete\n");
- }
-
-
-static void bt_ready(int err)
-{
-	struct bt_le_oob oob;
-
-	if (err) {
-		SYS_LOG_ERR("Bluetooth init failed (err %d", err);
-		return;
-	}
-
-	SYS_LOG_INF("Bluetooth initialized");
-
-	/* Use identity address as device UUID */
-if (bt_le_oob_get_local(&oob)) {
-		SYS_LOG_ERR("Identity Address unavailable");
-	} else {
-		memcpy(dev_uuid, oob.addr.a.val, 6);
-	}
-	err = bt_mesh_init(&prov, &comp);
-	if (err) {
-		SYS_LOG_ERR("Initializing mesh failed (err %d)", err);
-		return;
-	}
-
-	//bt_mesh_prov_enable(BT_MESH_PROV_GATT | BT_MESH_PROV_ADV);
-	SYS_LOG_INF("Mesh initialized");
-
-	err = bt_mesh_provision(net_key, net_idx, flags, iv_index, seq, addr,
-				dev_key);
-	if (err) {
-		printk("Provisioning failed (err %d)\n", err);
-		return;
-	}
-
-	printk("Provisioning completed\n");
-	configure();
-}
-
-void init_led(u8_t dev, const char *port, u32_t pin_num)
-{
-	onoff_state[dev].led_device = device_get_binding(port);
-	gpio_pin_configure(onoff_state[dev].led_device,
-			   pin_num, GPIO_DIR_OUT | GPIO_PUD_PULL_UP);
-	gpio_pin_write(onoff_state[dev].led_device, pin_num, 1);
-}
-
-/*
- * Log functions to identify output with the node
- */
-
-void log_cbuf_put(const char *format, ...)
-{
-	va_list args;
-	char buf[250];
-
-	va_start(args, format);
-	vsnprintf(buf, sizeof(buf), format, args);
-	va_end(args);
-	printk("[%04x] %s", primary_addr, buf);
-}
-
-void board_init(u16_t *addr, u32_t *seq)
-{
-	*addr = NODE_ADDR;
-	*seq = 0;
-}
-void main(void)
-{
-	int err;
-
-	/*
-	 * Initialize the logger hook
-	 */
-	syslog_hook_install(log_cbuf_put);
-
-	SYS_LOG_INF("Initializing...");
-	board_init(&addr, &seq);
-	/* Initialize the button debouncer */
-	last_time = k_uptime_get_32();
-
-	/* Initialize button worker task*/
-	k_work_init(&sw.button_work, button_pressed_worker);
-
-	/* Initialize button count timer */
-	k_timer_init(&sw.button_timer, button_cnt_timer, NULL);
-
-	sw_device = device_get_binding(SW0_GPIO_NAME);
-	gpio_pin_configure(sw_device, SW0_GPIO_PIN,
-			  (GPIO_DIR_IN | GPIO_INT | GPIO_INT_EDGE |
-			   GPIO_INT_ACTIVE_LOW | GPIO_PUD_PULL_UP));
-	gpio_pin_configure(sw_device, SW1_GPIO_PIN,
-			  (GPIO_DIR_IN | GPIO_INT | GPIO_INT_EDGE |
-			   GPIO_INT_ACTIVE_LOW | GPIO_PUD_PULL_UP));
-	gpio_pin_configure(sw_device, SW2_GPIO_PIN,
-			  (GPIO_DIR_IN | GPIO_INT | GPIO_INT_EDGE |
-			   GPIO_INT_ACTIVE_LOW | GPIO_PUD_PULL_UP));
-	gpio_pin_configure(sw_device, SW3_GPIO_PIN,
-			  (GPIO_DIR_IN | GPIO_INT | GPIO_INT_EDGE |
-			   GPIO_INT_ACTIVE_LOW | GPIO_PUD_PULL_UP));
-	gpio_init_callback(&button_cb, button_pressed,
-			   BIT(SW0_GPIO_PIN) | BIT(SW1_GPIO_PIN) |
-			   BIT(SW2_GPIO_PIN) | BIT(SW3_GPIO_PIN));
-	gpio_add_callback(sw_device, &button_cb);
-	gpio_pin_enable_callback(sw_device, SW0_GPIO_PIN);
-	gpio_pin_enable_callback(sw_device, SW1_GPIO_PIN);
-	gpio_pin_enable_callback(sw_device, SW2_GPIO_PIN);
-	gpio_pin_enable_callback(sw_device, SW3_GPIO_PIN);
-
-	/* Initialize LED's */
-	init_led(0, LED0_GPIO_PORT, LED0_GPIO_PIN);
-	init_led(1, LED1_GPIO_PORT, LED1_GPIO_PIN);
-	init_led(2, LED2_GPIO_PORT, LED2_GPIO_PIN);
-	init_led(3, LED3_GPIO_PORT, LED3_GPIO_PIN);
-
-	/* Initialize the Bluetooth Subsystem */
-	err = bt_enable(bt_ready);
-	if (err) {
-		SYS_LOG_ERR("Bluetooth init failed (err %d)", err);
-	}
-
-
-
-}
diff --git a/subsys/bluetooth/host/mesh/CMakeLists.txt b/subsys/bluetooth/host/mesh/CMakeLists.txt
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/TODO b/subsys/bluetooth/host/mesh/TODO
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/access.c b/subsys/bluetooth/host/mesh/access.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/access.h b/subsys/bluetooth/host/mesh/access.h
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/adv.c b/subsys/bluetooth/host/mesh/adv.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/adv.h b/subsys/bluetooth/host/mesh/adv.h
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/aodv_control_messages.c b/subsys/bluetooth/host/mesh/aodv_control_messages.c
index 60411ed..affcf89 100755
--- a/subsys/bluetooth/host/mesh/aodv_control_messages.c
+++ b/subsys/bluetooth/host/mesh/aodv_control_messages.c
@@ -7,23 +7,19 @@
  */
 
 /* -- Includes -- */
-#include <stdint.h>
 #include <zephyr.h>
-#include <errno.h>
-#include <misc/byteorder.h>
 #include <net/buf.h>
-#include <bluetooth/bluetooth.h>
 #include <bluetooth/mesh.h>
+
 #include "common/log.h"
-#include "adv.h"
+#include "routing_table.h"
 #include "mesh.h"
 #include "net.h"
 #include "transport.h"
 #include "access.h"
 #include "foundation.h"
-#include "aodv_control_messages.h"
-#include "routing_table.h"
 
+#include "aodv_control_messages.h"
 #define BT_DBG_ENABLED IS_ENABLED(CONFIG_BT_MESH_DEBUG_ROUTING)
 
 /**
@@ -42,12 +38,19 @@ struct k_mem_slab rrep_slab;
  *	@brief Ring search timer to opt out of ring search and
  * 				 increase the TTL value
  */
+ sys_slist_t rerr_list;
+ /* _HELLO_ */
+ sys_slist_t hello_msg_list;
+ struct k_mem_slab hello_msg_slab;
+ /* _HELLO_ */
+
 struct ring_search_flag_timer {
 	struct k_timer ring_timer;
 	/** When the timer expires, this flag is set */
 	bool ring_flag;
 };
 
+
 /* DEFINITIONS */
 #define INRANGE(new_seq, existing_seq) ((new_seq > existing_seq) ? 1 : 0)  /* FIXME handle wrapping and IV index? */
 #define rrep_rwait_list_NUMBER_OF_ENTRIES 20
@@ -57,13 +60,47 @@ K_MEM_SLAB_DEFINE(rrep_slab, RREP_ENTRY_SIZE, rrep_rwait_list_NUMBER_OF_ENTRIES,
 K_SEM_DEFINE(rrep_rwait_list_sem, 1, 1);  /* Binary semaphore for RREP linked list critical section */
 
 /* FUNCTIONS PROTOTYPES */
-static int rreq_send(struct rreq_data *data, u8_t TTL, u16_t net_idx);
+static bool rreq_send(struct rreq_data *data, u8_t TTL, u16_t net_idx);
 static void rreq_recv_cb(struct k_timer *timer_id);
 static void ring_search_timer(struct k_timer *timer_id);
-static int rrep_send(struct rrep_data *RREP_msg,u16_t net_idx, u16_t dst );
-static int rrep_rwait_list_create_entry(struct rrep_rwait_list_entry *entry_data);
+static bool rrep_send(struct rrep_data *RREP_msg,u16_t net_idx, u16_t dst );
+static bool rrep_rwait_list_create_entry(struct rrep_rwait_list_entry *entry_data);
 static void rwait_send(struct rreq_data* rreq_recv_data,struct bt_mesh_route_entry *destination_entry,
-	struct rwait_data rwait_data, struct bt_mesh_net_rx* rx, bool relay);
+struct rwait_data rwait_data, struct bt_mesh_net_rx* rx, bool relay);
+
+/* _RERR_ */
+struct k_mem_slab rerr_slab;
+#define rerr_list_NUMBER_OF_ENTRIES 20
+#define RERR_ENTRY_SIZE sizeof(struct rerr_list_entry)
+
+#define hello_msg_list_NUMBER_OF_ENTRIES 20
+#define HELLO_MSG_ENTRY_SIZE sizeof(struct hello_msg_list_entry)
+
+K_MEM_SLAB_DEFINE(rerr_slab, RERR_ENTRY_SIZE, rerr_list_NUMBER_OF_ENTRIES, ALLIGNED);
+K_SEM_DEFINE(rerr_list_sem, 1, 1);  /* Binary semaphore for RREP linked list critical section */
+
+K_MEM_SLAB_DEFINE(hello_msg_slab, HELLO_MSG_ENTRY_SIZE, hello_msg_list_NUMBER_OF_ENTRIES, ALLIGNED);
+K_SEM_DEFINE(hello_msg_list_sem, 1, 1);  /* Binary semaphore for hello message linked list critical section */
+
+static bool rerr_send(struct rerr_list_entry *data);
+bool bt_mesh_search_rerr_list(u16_t next_hop,u16_t net_idx,struct rerr_list_entry **entry);
+bool bt_mesh_create_rerr_entry(struct rerr_list_entry **entry_data);
+void bt_mesh_delete_rerr_entry(struct rerr_list_entry *entry);
+void callback(struct bt_mesh_route_entry *entry1);
+bool is_empty_rerr();
+/*Reham*/
+bool is_empty_hello_msg_list();
+int hello_msg_list_create_entry(struct hello_msg_list_entry **entry_data);
+int hello_msg_list_search_entry(u16_t src, struct hello_msg_list_entry **entry_data);
+/*Reham*/
+void bt_mesh_delete_hello_msg_entry(struct hello_msg_list_entry *entry);
+/* _RERR_ */
+
+/* _TEST_ */
+//struct k_timer hello_send;        				/* hello timer (52B) */
+/* _TEST_ */
+
+
 /*static void view_rrep_rwait_list();*/
 
 /* FUNCTIONS IMPLEMENTATION */
@@ -80,10 +117,12 @@ static void rwait_send(struct rreq_data* rreq_recv_data,struct bt_mesh_route_ent
  *							Usually set by bt_mesh_trans_ring_search.
  *	@param net_idx: Unsigned integer
  *
- *	@return : 0 on success. Otherwise, sending control message failed
+ *	@return RANA:
  */
-static int rreq_send(struct rreq_data *data, u8_t TTL, u16_t net_idx)
+static bool rreq_send(struct rreq_data *data, u8_t TTL, u16_t net_idx)
 {
+	/*data -> destination_address = 0x0e0e;*/ /* TESTING */
+
 	/* Concatenate RREQ flags into 1 byte */
 	u8_t flags = data->G + (data->D << 1) + (data->U << 2) + (data->I << 3);
 	/* Default network layer next hop is to broadcast to all nodes */
@@ -101,12 +140,6 @@ static int rreq_send(struct rreq_data *data, u8_t TTL, u16_t net_idx)
 		network_next_hop = entry->next_hop;
 	}
 
-	BT_DBG("source_address 0x%04x destination_address 0x%04x next_hop 0x%04x",
-	 data->source_address, data->destination_address,data->next_hop);
-	BT_DBG("source_number_of_elements %04x hop_count %01x source_sequence_number %08x",
-		data->source_number_of_elements, data->hop_count, data->source_sequence_number)
-	BT_DBG("destination_sequence_number  %08x ", data->destination_sequence_number)
-
 	struct bt_mesh_msg_ctx ctx =
 	{
 		.app_idx  = BT_MESH_KEY_UNUSED, /* Control messages have no app index */
@@ -125,24 +158,27 @@ static int rreq_send(struct rreq_data *data, u8_t TTL, u16_t net_idx)
 	};
 
 	/* Add RREQ data in a buffer to be sent */
+	net_buf_simple_add_mem(&buf, &data->hop_count, 1);
 	net_buf_simple_add_mem(&buf, &data->source_address, 2);
 	net_buf_simple_add_mem(&buf, &data->destination_address, 2);
 	net_buf_simple_add_mem(&buf, &data->source_number_of_elements, 2);
 	net_buf_simple_add_mem(&buf, &data->hop_count, 1);
-	net_buf_simple_add_mem(&buf, &data->rssi, 1);
 	net_buf_simple_add_mem(&buf, &flags, 1);
 	net_buf_simple_add_mem(&buf, &data->source_sequence_number, 3);
 	if (data->U == 0)
 	{
 		/* Add the destination sequence number if it's known */
-		printk("here \n");
 		net_buf_simple_add_mem(&buf, &data->destination_sequence_number, 3);
 	}
 
 	/* Send the constructed buffer to the transport layer */
 	int err = bt_mesh_ctl_send(&tx, TRANS_CTL_OP_RREQ, buf.data, buf.len, NULL, NULL, NULL);
 
-	return err;
+	if (err != 0) { /* FIXME */
+		return false;
+	} else   {
+		return true;
+	}
 }
 
 /**
@@ -197,13 +233,9 @@ static void ring_search_timer(struct k_timer *timer_id)
  *						 the received network layer data.
  *	@param buf: Pointer to a structure of type net_buf_simple that holds
  *							the received RREQ data.
- *	@return : 0 on Success
- 			  -ELOCAL when source address is a local element
- 			  -ENORREQ when RREP interval has expired
-
-
+ *	@return RANA:
  */
-int bt_mesh_trans_rreq_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf)
+bool bt_mesh_trans_rreq_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf)
 {
 	/* Dissect the received RREQ into fields */
 	struct rreq_data temp;
@@ -212,7 +244,6 @@ int bt_mesh_trans_rreq_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *bu
 	data->destination_address = RREQ_GET_DST_ADDR(buf);
 	data->source_number_of_elements = RREQ_GET_SRC_NUMBER_OF_ELEMENTS(buf);
 	data->hop_count = RREQ_GET_HOP_COUNT(buf);
-	data->rssi=(RREQ_GET_RSSI(buf) * (data->hop_count ) + rx->rssi)/(data->hop_count + 1);
 	data->next_hop = rx->ctx.addr;
 	data->G = RREQ_GET_G_FLAG(buf);
 	data->D = RREQ_GET_D_FLAG(buf);
@@ -221,50 +252,26 @@ int bt_mesh_trans_rreq_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *bu
 	data->destination_sequence_number = RREQ_GET_DST_SEQ(buf);
 	data->source_sequence_number = RREQ_GET_SRC_SEQ(buf);
 
-	/* TESTING: Test sent RREQ data is correct. */
-		 printk("Source Address=%04x \n",RREQ_GET_SRC_ADDR(buf));
-		 printk("Destination Address=%04x \n",RREQ_GET_DST_ADDR(buf));
-		 printk("Source Number of Elements=%04x \n",RREQ_GET_SRC_NUMBER_OF_ELEMENTS(buf));
-		 printk("Hop Count=%d \n",RREQ_GET_HOP_COUNT(buf));
-		 printk("rssi=%d \n",RREQ_GET_RSSI(buf));
-		 printk("G Flag=%d \n",RREQ_GET_G_FLAG(buf));
-		 printk("D Flag=%d \n",RREQ_GET_D_FLAG(buf));
-		 printk("U Flag=%d \n",RREQ_GET_U_FLAG(buf));
-		 printk("I Flag=%d \n",RREQ_GET_I_FLAG(buf));
-		 printk("Destination Sequence Number=%08x \n",RREQ_GET_DST_SEQ(buf));
-
-
-	BT_DBG("source_address 0x%04x destination_address 0x%04x next_hop 0x%04x",
-	 data->source_address, data->destination_address,data->next_hop);
-	BT_DBG("source_number_of_elements %04x hop_count %01x source_sequence_number %08x",
-		data->source_number_of_elements, data->hop_count, data->source_sequence_number)
-	BT_DBG("destination_sequence_number  %08x ", data->destination_sequence_number)
-	printk("RSSI average = %d\n",data->rssi);
-
-
-
 	struct bt_mesh_route_entry *entry = NULL;
 	/* If element is requesting data transaction from an element in the same node,
 	 * Drop rreq. This case is to prevent receiving RREQ from neighbouring elements */
 	if (bt_mesh_elem_find(data->source_address))
 	{
-		BT_ERR("Source address is a local element");
-		return -ELOCAL;
+		return 0;
 	}
 	/* If a RREQ is received by the destination node */
 	else if (bt_mesh_elem_find(data->destination_address))
 	{
 		/* Drop any received RREQ after the expiry of the ring search timer */
 		if (bt_mesh_search_valid_destination(data->destination_address, data->source_address, &entry)) {
-			BT_ERR("RREQ dropped - RREQ received after RREP Interval");
 			printk("RREQ dropped - RREQ received after RREP Interval\n");
-			return -ENORREQ;
+			return 0;
 		}
 		/* Multiple RREQs are received in the interval of ring search timer */
 		else if (bt_mesh_search_invalid_destination(data->destination_address, data->source_address, &entry))
 		{
 			/* If it contains better data, replace */
-			if ((data->hop_count*10+(data->rssi*10)/RSSI_MIN) < (entry->hop_count*10+(entry->rssi*10)/RSSI_MIN)) {
+			if (data->hop_count < entry->hop_count) {
 				printk("Modifying existing entry \n");
 				entry->destination_sequence_number = data->destination_sequence_number;
 				entry->hop_count                   = data->hop_count;
@@ -286,14 +293,9 @@ int bt_mesh_trans_rreq_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *bu
 			entry_data->source_number_of_elements      = bt_mesh_elem_count();
 			entry_data->destination_number_of_elements = data->source_number_of_elements;
 			entry_data->hop_count                      = data->hop_count;
-			entry_data->rssi 													 = data-> rssi;
 			entry_data->net_idx 											 = rx -> ctx.net_idx;
-			return 0;
 			}
-			else {
-				return false;
-			}
-
+			return 0;
 		}
 	}
 	/* Intermediate node having route to destination should
@@ -308,15 +310,14 @@ int bt_mesh_trans_rreq_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *bu
 		struct bt_mesh_route_entry *entry_data;
 		if (bt_mesh_create_entry_invalid(&entry_data))
 		{
-			entry_data->source_address                 = data->destination_address;
-			entry_data->destination_address            = data->source_address;
-			entry_data->destination_sequence_number    = data->source_sequence_number;
-			entry_data->next_hop                       = data->next_hop;
-			entry_data->source_number_of_elements      = 1; /* Will be corrected by RREP */
-			entry_data->destination_number_of_elements = data->source_number_of_elements;
-			entry_data->hop_count                      = data->hop_count;
-			entry_data->rssi 													 = data-> rssi;
-			entry_data->net_idx 											 = rx -> ctx.net_idx;
+		entry_data->source_address                 = data->destination_address;
+		entry_data->destination_address            = data->source_address;
+		entry_data->destination_sequence_number    = data->source_sequence_number;
+		entry_data->next_hop                       = data->next_hop;
+		entry_data->source_number_of_elements      = 1; /* Will be corrected by RREP */
+		entry_data->destination_number_of_elements = data->source_number_of_elements;
+		entry_data->hop_count                      = data->hop_count;
+		entry_data->net_idx 												= rx -> ctx.net_idx;
 		}
 		else
 		{
@@ -332,7 +333,6 @@ int bt_mesh_trans_rreq_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *bu
 			printk("SEND RWAIT and SEND RREQ with flag I=1 \n");
 			data->I = 1;
 			data->hop_count = data->hop_count + 1;
-			data->rssi=(RREQ_GET_RSSI(buf) * (data->hop_count + 1 ) + rx->rssi)/(data->hop_count + 2);
 			rreq_send(data, 1, rx->ctx.net_idx); /* To RREQ's destination */
 			struct rwait_data temp; /* Dummy struct */
 			entry_data->hop_count = entry -> hop_count;
@@ -350,39 +350,45 @@ int bt_mesh_trans_rreq_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *bu
 			struct bt_mesh_route_entry *entry_data;
 			if(bt_mesh_create_entry_invalid(&entry_data))
 			{
-				entry_data->source_address                 = data->destination_address;
-				entry_data->destination_address            = data->source_address;
-				entry_data->destination_sequence_number    = data->source_sequence_number;
-				entry_data->next_hop                       = data->next_hop;
-				entry_data->source_number_of_elements      = 1; /* UNKNOWN. Will be corrected by RREP */
-				entry_data->destination_number_of_elements = data->source_number_of_elements;
-				entry_data->hop_count                      = data->hop_count;
-				entry_data->rssi 													 = data-> rssi;
-				entry_data->net_idx 											 = rx -> ctx.net_idx;
-
-			data->next_hop = data->next_hop + 1;
-			/* Relay the received RREQ */
-			return rreq_send(data, rx->ctx.recv_ttl - 1, rx->ctx.net_idx);
+			entry_data->source_address                 = data->destination_address;
+			entry_data->destination_address            = data->source_address;
+			entry_data->destination_sequence_number    = data->source_sequence_number;
+			entry_data->next_hop                       = data->next_hop;
+			entry_data->source_number_of_elements      = 1; /* UNKNOWN. Will be corrected by RREP */
+			entry_data->destination_number_of_elements = data->source_number_of_elements;
+			entry_data->hop_count                      = data->hop_count;
+			entry_data->net_idx 											 = rx -> ctx.net_idx;
 			}
 			else {
 				return false;
 			}
-
+			data->next_hop = data->next_hop + 1;
+			/* Relay the received RREQ */
+			return rreq_send(data, rx->ctx.recv_ttl - 1, rx->ctx.net_idx);
 		}
+
 		/* If an invalid entry was found and the stored destination sequence
 		 * 	is fresher than the received one, refresh the route entry timer
 		 */
 		else if (entry->destination_sequence_number < data->source_sequence_number)
 		{
 			entry->destination_sequence_number = data->source_sequence_number;
-			entry->rssi = data-> rssi;
-			data-> hop_count = data -> hop_count + 1;
 			bt_mesh_refresh_lifetime_invalid(entry);
 			return rreq_send(data, rx->ctx.recv_ttl - 1, rx->ctx.net_idx);
 		}
 	}
 
-
+	/* TESTING: Test sent RREQ data is correct.
+		 printk("Source Address=%04x \n",RREQ_GET_SRC_ADDR(buf));
+	   printk("Destination Address=%04x \n",RREQ_GET_DST_ADDR(buf));
+	   printk("Source Number of Elements=%04x \n",RREQ_GET_SRC_NUMBER_OF_ELEMENTS(buf));
+	   printk("Hop Count=%d \n",RREQ_GET_HOP_COUNT(buf));
+	   printk("G Flag=%d \n",RREQ_GET_G_FLAG(buf));
+	   printk("D Flag=%d \n",RREQ_GET_D_FLAG(buf));
+	   printk("U Flag=%d \n",RREQ_GET_U_FLAG(buf));
+	   printk("I Flag=%d \n",RREQ_GET_I_FLAG(buf));
+	   printk("Destination Sequence Number=%08x \n",RREQ_GET_DST_SEQ(buf));
+	 */
 	 return 0;
 }
 
@@ -393,16 +399,17 @@ int bt_mesh_trans_rreq_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *bu
  *	@param tx: Pointer to a structure of type bt_mesh_net_tx that holds
  *						 the transmitted network layer data.
  *
- *	@return :0 on success, -ENORREP if RREP interval has expired
+ *	@return RANA:
  */
 u8_t bt_mesh_trans_ring_search(struct bt_mesh_net_tx *tx)
 {
 	u16_t source_address = tx->src; /* Primary element source address */
 	u16_t destination_address = tx->ctx->addr; /* TODO: BT_MESH_ADDR_ALL_NODES ? */
+
 	/* The following 2 fields will be set if
 	 * an invalid route is found to destination */
 	u32_t destination_sequence_number = 0;
-	bool U_flag = 1; /* Unknown destination sequence number flag */
+	bool U_flag = 0; /* Unknown destination sequence number flag */
 
 	/* Create a ring search timer */
 	struct ring_search_flag_timer ring_struct;
@@ -419,8 +426,7 @@ u8_t bt_mesh_trans_ring_search(struct bt_mesh_net_tx *tx)
 	if (bt_mesh_search_invalid_destination(source_address, destination_address, &entry))
 	{
 		destination_sequence_number = entry->destination_sequence_number;
-		printk("destination sequence number %08x \n",destination_sequence_number);
-		U_flag = 0;
+		U_flag = 1;
 	}
 
 	/* Construct RREQ data to be sent */
@@ -433,7 +439,6 @@ u8_t bt_mesh_trans_ring_search(struct bt_mesh_net_tx *tx)
 		.source_number_of_elements = bt_mesh_elem_count(),
 		.destination_sequence_number = destination_sequence_number
 	};
-	printk("Destination Address : %04x\n",destination_address);
 	rreq_send(&data, TTL, tx->ctx->net_idx);
 
 	/* Keep searching the rrep_rwait_list till an entry is found.
@@ -468,7 +473,7 @@ u8_t bt_mesh_trans_ring_search(struct bt_mesh_net_tx *tx)
 				sys_slist_find_and_remove(&rrep_rwait_list, &temp->node);
 				k_sem_give(&rrep_rwait_list_sem);
 				k_mem_slab_free(&rrep_slab, (void **)&temp);
-				return 0;
+				return 1;
 			}
 		}
 		k_sem_give(&rrep_rwait_list_sem); /*return semaphore */
@@ -488,8 +493,7 @@ u8_t bt_mesh_trans_ring_search(struct bt_mesh_net_tx *tx)
 			if (TTL == RREQ_RING_SEARCH_MAX_TTL)
 			{
 				k_timer_stop(&ring_struct.ring_timer);
-				BT_ERR("max TTL is reached. Ring search has stopped");
-				return -ENORREP;
+				return 0;
 			}
 		}
 		/* Sleep so as not to search the list continiously */
@@ -510,9 +514,9 @@ u8_t bt_mesh_trans_ring_search(struct bt_mesh_net_tx *tx)
  *	@param destination_address: Unsigned integer that holds the next hop
  *															destination from the reverse route entry.
  *
- *	@return : 0 on success. Otherwise, sending control message failed
+ *	@return RANA:
  */
-static int  rrep_send(struct rrep_data *data,u16_t net_idx, u16_t destination_address )
+static bool rrep_send(struct rrep_data *data,u16_t net_idx, u16_t destination_address )
 {
 	/* TODO : check when rreq_recv is calling rrep_send */
 	struct bt_mesh_msg_ctx ctx =
@@ -540,12 +544,6 @@ static int  rrep_send(struct rrep_data *data,u16_t net_idx, u16_t destination_ad
 	printk("RREP elem 0x%04x \n", RREP_msg->destination_number_of_elements);
 	*/
 
-	BT_DBG("source_address 0x%04x destination_address 0x%04x destination_sequence_number 0x%08x",
-	 data->source_address, data->destination_address,data->destination_sequence_number);
-	BT_DBG("hop_count %01x destination_number_of_elements %04x",
-		data->hop_count, data->destination_number_of_elements)
-
-
 	/* Create a buffer for RREP data */
 	NET_BUF_SIMPLE_DEFINE(buf, RREP_SDU_MAX_SIZE);
 	net_buf_simple_add_mem(&buf, &data->R, 1); /* FIXME: should be 1 bit only. */
@@ -554,6 +552,7 @@ static int  rrep_send(struct rrep_data *data,u16_t net_idx, u16_t destination_ad
 	net_buf_simple_add_mem(&buf, &data->destination_sequence_number, 4);
 	net_buf_simple_add_mem(&buf, &data->hop_count, 1);
 	net_buf_simple_add_mem(&buf, &data->destination_number_of_elements, 2);
+
 	return bt_mesh_ctl_send(&tx, TRANS_CTL_OP_RREP, buf.data,
 				buf.len, NULL, NULL, NULL);
 }
@@ -564,9 +563,9 @@ static int  rrep_send(struct rrep_data *data,u16_t net_idx, u16_t destination_ad
  *	@param data: Pointer to a structure of type rrep_data that holds the
  *							 received hop count and RREQ's destination.
  *
- *	@return : 0 on sucess, -ENOSR if memory allocation timeout
+ *	@return RANA:
  */
-static int rrep_rwait_list_create_entry(struct rrep_rwait_list_entry *entry_data)
+static bool rrep_rwait_list_create_entry(struct rrep_rwait_list_entry *entry_data)
 {
   struct rrep_rwait_list_entry* entry_location=NULL;
 	/* Insert a new node into rrep_rwait_list */
@@ -579,11 +578,11 @@ static int rrep_rwait_list_create_entry(struct rrep_rwait_list_entry *entry_data
 	}
 	else {
 		/* Memory Allocation timeout */
-		return -ENOSR;
+		return false;
 	}
 	entry_location -> destination_address = entry_data -> destination_address;
 	entry_location -> hop_count = entry_data -> hop_count;
-	return 0;
+	return true;
 }
 
 /**
@@ -595,9 +594,9 @@ static int rrep_rwait_list_create_entry(struct rrep_rwait_list_entry *entry_data
  *	@param buf: Pointer to a structure of type net_buf_simple that holds
  *							the received RREP data.
  *
- *	@return : 0 on sucess, -ENOSR if memory allocation timeout
+ *	@return RANA:
  */
-int bt_mesh_trans_rrep_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf)
+bool bt_mesh_trans_rrep_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf)
 {
 	/* Dissect the RREP into its fields */
 	struct rrep_data temp;
@@ -609,7 +608,7 @@ int bt_mesh_trans_rrep_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *bu
 	data->hop_count = RREP_GET_HOP_COUNT(buf);
 	data->destination_number_of_elements = RREP_GET_SRC_NUMBER_OF_ELEMENTS(buf);
 
-	/* Testing: View received RREP  */
+	/* Testing: View received RREP data
 	printk("RREP R 0x%01x \n", data->R);
 	printk("RREP source_address 0x%04x \n", data->source_address);
 	printk("RREP dst 0x%04x \n", data->destination_address);
@@ -621,13 +620,7 @@ int bt_mesh_trans_rrep_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *bu
 	printk("Network recieved TL 0x%02x \n", rx->ctx.send_ttl);
 	printk("msg->src 0x%04x \n", data->source_address);
 	printk("bt_mesh_primary_addr() 0x%04x \n", bt_mesh_primary_addr());
-
-
-	BT_DBG("source_address 0x%04x destination_address 0x%04x destination_sequence_number 0x%08x",
-	 data->source_address, data->destination_address,data->destination_sequence_number);
-	BT_DBG("hop_count %01x destination_number_of_elements %04x",
-		data->hop_count, data->destination_number_of_elements)
-
+	*/
 
 	/* If the RREP is received by the RREQ originator */
 	if (data->source_address == bt_mesh_primary_addr())
@@ -637,28 +630,28 @@ int bt_mesh_trans_rrep_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *bu
 				(INRANGE(data->destination_sequence_number,found_entry->destination_sequence_number)
 				&& bt_mesh_invalidate_route(found_entry)))
 			{
-			/* Create forward entry */
-			struct bt_mesh_route_entry *table_entry;
-			if(bt_mesh_create_entry_valid(&table_entry))
-			{
-			table_entry->source_address                  = data->source_address;
-			table_entry->destination_address             = data->destination_address;
-			table_entry->destination_sequence_number     = data->destination_sequence_number;
-			table_entry->next_hop                        = rx->ctx.addr;
-			table_entry->hop_count                       = data->hop_count;
-			table_entry->destination_number_of_elements  = data->destination_number_of_elements;
-			table_entry->source_number_of_elements 			 = bt_mesh_elem_count();
-			table_entry->net_idx 												 = rx -> ctx.net_idx;
+				/* Create forward entry */
+				struct bt_mesh_route_entry *table_entry;
+				if(bt_mesh_create_entry_valid(&table_entry))
+				{
+				table_entry->source_address                  = data->source_address;
+				table_entry->destination_address             = data->destination_address;
+				table_entry->destination_sequence_number     = data->destination_sequence_number;
+				table_entry->next_hop                        = rx->ctx.addr;
+				table_entry->hop_count                       = data->hop_count;
+				table_entry->destination_number_of_elements  = data->destination_number_of_elements;
+				table_entry->source_number_of_elements 			 = bt_mesh_elem_count();
+				table_entry->net_idx 												 = rx -> ctx.net_idx;
+			}
+			else {
+					return false;
+			}
 			/* Create entry in rrep_rwait_list */
 			struct rrep_rwait_list_entry rrep_entry_temp;
 			struct rrep_rwait_list_entry *rrep_entry=&rrep_entry_temp;
 			rrep_entry->destination_address = data->destination_address;
 			rrep_entry->hop_count = data->hop_count;
 			return rrep_rwait_list_create_entry(rrep_entry);
-			}
-			else {
-				return false;
-			}
 		}
 	}
 	/* RREP is received by an intermediate node and should be directed
@@ -679,25 +672,21 @@ int bt_mesh_trans_rrep_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *bu
 			struct bt_mesh_route_entry *table_entry;
 			if(bt_mesh_create_entry_valid(&table_entry))
 			{
-			table_entry->source_address                  = data->source_address;
-			table_entry->destination_address             = data->destination_address;
-			table_entry->destination_sequence_number     = data->destination_sequence_number;
-			table_entry->next_hop                        = rx->ctx.addr;
-			table_entry->hop_count                       = data->hop_count;
-			table_entry->destination_number_of_elements  = data->destination_number_of_elements;
-			table_entry->source_number_of_elements 			= existing_entry->destination_number_of_elements;
-			table_entry->net_idx 												= rx -> ctx.net_idx;
-			data->hop_count++;
-			rrep_send(data, rx -> ctx.net_idx ,existing_entry->next_hop);
+				table_entry->source_address                  = data->source_address;
+				table_entry->destination_address             = data->destination_address;
+				table_entry->destination_sequence_number     = data->destination_sequence_number;
+				table_entry->next_hop                        = rx->ctx.addr;
+				table_entry->hop_count                       = data->hop_count;
+				table_entry->destination_number_of_elements  = data->destination_number_of_elements;
+				table_entry->source_number_of_elements 			= existing_entry->destination_number_of_elements;
+				table_entry->net_idx 												= rx -> ctx.net_idx;
 			}
-			else {
-				return false;
-			}
-
 
+			data->hop_count++;
+			rrep_send(data, rx -> ctx.net_idx ,existing_entry->next_hop);
 		}
 	}
-	return 0;
+	return true;
 }
 
 /**
@@ -743,7 +732,7 @@ static void view_rrep_rwait_list()
  *	@param rwait_data: Structure of type rwait_data holding the data to be sent.
  *	@param rx: Pointer to a structure of type bt_mesh_net_rx that holds
  *						 the received network layer data.
- *	@param relay: bool flag to determine whether this node has the destination entry or if it's only relaying a preformed RWait
+ *	@param relay: RANA:
  *
  *	@return N/A
  */
@@ -809,12 +798,8 @@ static void rwait_send(struct rreq_data* rreq_recv_data,struct bt_mesh_route_ent
 	 printk("Source Address=%04x \n",data.source_address);
    printk("Destination Address=%04x \n",data.destination_address);
    printk("Hop Count=%d \n",data.hop_count);
+	 printk("[send_Rwait]:: entry hop_count : 0x%01x \n", destination_entry->hop_count);
 	*/
-
-	BT_DBG("source_address 0x%04x Destination Address 0x%04x Hop Count 0x%01x",
-	 data.source_address, data.destination_address,data.hop_count);
-
-
 	bt_mesh_ctl_send(&tx, TRANS_CTL_OP_RWAIT, sdu->data,sdu->len, NULL, NULL, NULL);
 
 }
@@ -847,10 +832,6 @@ void bt_mesh_trans_rwait_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *
 	data -> source_sequence_number = RWAIT_GET_SRC_SEQ_NUM(buf);
 	data -> hop_count= RWAIT_GET_HOP_COUNT(buf);
 
-	BT_DBG("source_address 0x%04x Destination Address 0x%04x Hop Count 0x%01x",
-	 data -> destination_address, data -> source_address,data -> hop_count);
-
-
 	/* TESTING : Display the received RWAit
 	printk("Rwait dst 0x%04x \n", data->destination_address);
 	printk("Rwait src 0x%04x \n", data->source_address);
@@ -884,7 +865,7 @@ void bt_mesh_trans_rwait_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *
 	}
 	/* RWAIT is received by an intermediate node */
 	else {
-		/* FIXME: Comment this section */
+		/* XXX: Comment this section */
 		if (!bt_mesh_search_invalid_destination(rx->ctx.addr, rx->dst, &temp))
 		{
 			/* FIXME: remove the struct */
@@ -901,3 +882,393 @@ void bt_mesh_trans_rwait_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *
 		}
 	}
 }
+
+
+/* _RERR_ */
+/* _TEST_ */
+//static void hello_publish(struct k_timer *timer_id);
+/* _TEST_ */
+void bt_mesh_trans_rerr_list_init()
+{
+	sys_slist_init(&rerr_list);
+  /* _TEST_ */
+  //k_timer_init (&hello_send, hello_publish, NULL);
+  //k_timer_start(&hello_send, HELLO_MSG_SEND, 0);
+  /* _TEST_ */
+}
+
+
+bool bt_mesh_search_rerr_list(u16_t next_hop,u16_t net_idx,struct rerr_list_entry **entry)
+{
+	struct rerr_list_entry *entry1 = NULL;
+	k_sem_take(&rerr_list_sem, K_FOREVER);
+	SYS_SLIST_FOR_EACH_CONTAINER(&rerr_list, entry1, node){
+		/* Search for the destination and source addresses in their range of elements */
+		if ((entry1->next_hop==next_hop) &&(entry1->net_idx==net_idx)) {
+			k_sem_give(&rerr_list_sem);
+			*entry = entry1; //FIXME entry and entry1 might later point to a deleted entries by another thread
+			return true;}
+		}
+		k_sem_give(&rerr_list_sem);
+		return false;
+}
+
+bool bt_mesh_create_rerr_entry(struct rerr_list_entry **entry_location)
+{
+	/* Insert a new node into rrep_rwait_list */
+	if (k_mem_slab_alloc(&rerr_slab, (void **)&(*entry_location), 100) == 0)
+	{
+		memset((*entry_location), 0, RERR_ENTRY_SIZE);
+		k_sem_take(&rerr_list_sem, K_FOREVER);
+		sys_slist_append(&rerr_list, &(*entry_location)->node);
+		k_sem_give(&rerr_list_sem);
+	}
+	else {
+		/* Memory Allocation timeout */
+		return false;
+	}
+	return true;
+}
+
+void bt_mesh_delete_rerr_entry(struct rerr_list_entry *entry )
+{
+		k_sem_take(&rerr_list_sem, K_FOREVER);   							/* take semaphore */
+		sys_slist_find_and_remove(&rerr_list, &entry->node);   /*delete node from linked list */
+		k_sem_give(&rerr_list_sem);                            /*return semaphore */
+		k_mem_slab_free(&rerr_slab, (void **)&entry);  /*free space in slab*/
+}
+
+static bool rerr_send(struct rerr_list_entry *data)
+{/*only used by intermediate nodes*/
+	struct bt_mesh_msg_ctx ctx =
+	{
+		.app_idx  = BT_MESH_KEY_UNUSED,
+		.net_idx  = data->net_idx,
+		.send_ttl = 3  /* FIXME */
+	};
+
+	struct bt_mesh_net_tx tx = {
+		.sub = bt_mesh_subnet_get(data->net_idx),
+		.ctx = &ctx,
+		.xmit = bt_mesh_net_transmit_get(),
+	};
+	tx.ctx->addr = data->next_hop;
+	tx.src = bt_mesh_primary_addr();
+	tx.ctx->send_ttl--;
+	BT_DBG("RERR Send: \n");
+	BT_DBG("destination_number =%01x : ", data->destination_number);
+	/* Create a buffer for RRER data */
+	NET_BUF_SIMPLE_DEFINE (buf, BT_MESH_TX_SDU_MAX);
+	net_buf_simple_add_mem(&buf, &data->destination_number, 1);
+	for (int i=0; i<data->destination_number && i< 10 ;i++) //FIXME
+	{
+		net_buf_simple_add_mem(&buf, &data->destination_address[i], 2);
+		net_buf_simple_add_mem(&buf, &data->destination_sequence_number[i], 3);
+		BT_DBG("destination_address =%04x , destination_sequence_number = %04x  ", data->destination_address[i], data->destination_sequence_number[i]);
+
+	}
+	BT_DBG("sent to =%04x : ", data->next_hop);
+
+	return bt_mesh_ctl_send(&tx, TRANS_CTL_OP_RERR, buf.data,
+				buf.len, NULL, NULL, NULL);
+}
+
+
+bool bt_mesh_trans_rerr_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf)
+{
+	struct rerr_list_entry temp;
+	struct rerr_list_entry *data = &temp;
+	data->destination_number= RERR_GET_DST_NUM(buf);
+	u16_t destination_address;
+	u32_t destination_sequence_number;
+	/*Loop to obtain all destinations inside the buffer */
+	BT_DBG("RERR RECV: \n");
+	BT_DBG("destination_number =%01x : ", data->destination_number);
+	for (int i=0; i<data->destination_number;i++)
+	{
+		destination_address = RERR_GET_DST_ADDR(buf,i*2 + i*3 +1);
+		destination_sequence_number= RERR_GET_DST_SEQ_NUM(buf,i*2 + i*3 +1);
+ 		BT_DBG("destination_address =%04x , destination_sequence_number = %04x  ", destination_address, destination_sequence_number);
+ 		/*invoke the function destination_address destination_sequence_number */
+		bt_mesh_search_valid_with_cb(destination_address,rx->ctx.addr,rx->ctx.net_idx,callback);
+	}
+	BT_DBG("received from =%04x : ", rx->dst);
+
+		/*	loop over the RERR list and send each entry	*/
+	struct rerr_list_entry* rerr_rx_entry=NULL;
+	k_sem_take(&rerr_list_sem, K_FOREVER);
+	while(!is_empty_rerr())
+	{SYS_SLIST_FOR_EACH_CONTAINER(&rerr_list, rerr_rx_entry, node)
+	{
+		rerr_send(rerr_rx_entry);
+	 bt_mesh_delete_rerr_entry(rerr_rx_entry);
+	}
+}
+	k_sem_give(&rerr_list_sem);
+	view_valid_list();
+  view_invalid_list();
+  view_hello_msg_list();
+  view_rerr_list();
+
+	return true;
+}
+
+
+void callback(struct bt_mesh_route_entry *entry1)
+{					/*Terminal node*/
+	if ( entry1->source_address==bt_mesh_primary_addr())
+	{
+		bt_mesh_invalidate_route(entry1); //TODO: delete it instead
+	}
+	else /*I-node*/
+	{
+		struct bt_mesh_route_entry *entry = NULL;
+		struct rerr_list_entry *rerr_entry=NULL;
+		bt_mesh_search_valid_destination_with_idx(entry1->destination_address,entry1->source_address,entry1->net_idx,&entry); /*TODO:implement*/
+		if (bt_mesh_search_rerr_list(entry->next_hop,entry->net_idx, &rerr_entry)) /*TODO:implement*/
+		{/*Add another dst*/
+				rerr_entry->destination_address[rerr_entry->destination_number]=entry1->destination_address;
+				rerr_entry->destination_sequence_number[rerr_entry->destination_number]=entry1->destination_sequence_number;
+				rerr_entry->destination_number++ ;
+		}
+		else /*create RERR entry */
+		{
+			bt_mesh_create_rerr_entry(&rerr_entry); /*TODO: implement*/
+			rerr_entry->destination_number=1;
+			rerr_entry->next_hop=entry->next_hop;
+			rerr_entry->net_idx=entry1->net_idx;
+			rerr_entry->destination_address[0]=entry1->destination_address;
+			rerr_entry->destination_sequence_number[0]=entry1->destination_sequence_number;
+		}
+			bt_mesh_invalidate_route(entry1);
+			bt_mesh_invalidate_route(entry);
+	}
+}
+
+void view_rerr_list()
+{
+	if (sys_slist_is_empty(&rerr_list)) {
+		printk("rerr is empty \n");
+		return;
+	}
+	struct rerr_list_entry *entry = NULL;
+	k_sem_take(&rerr_list_sem, K_FOREVER);
+	SYS_SLIST_FOR_EACH_CONTAINER(&rerr_list, entry, node){
+		printk("\x1b[34mRERR List:destination number=%04x,nexthop address=%04x \x1b[0m\n", entry->destination_number, entry->next_hop);
+	}
+	k_sem_give(&rerr_list_sem);
+}
+
+
+bool is_empty_rerr()
+{
+	if (sys_slist_is_empty(&rerr_list)) {
+		printk("RERR List is empty \n");
+		return true;
+	}
+	return false;
+}
+
+/*Reham*/
+bool is_empty_hello_msg_list()
+{
+	if (sys_slist_is_empty(&hello_msg_list)) {
+		printk("Hello msg List is empty \n");
+		return true;
+	}
+	return false;
+}
+
+
+
+/*Reham*/
+void bt_mesh_delete_hello_msg_entry_timer(struct k_timer *timer_id)
+{
+	//printk("timer expired \n");
+	/*fetching the entry of the expired timer to get its next hop*/
+	struct hello_msg_list_entry *entry = CONTAINER_OF(timer_id, struct hello_msg_list_entry, lifetime);
+	printk("timer expired for source address=%04x \n", entry->source_address);
+
+	/*start searching for the entry in the valid list */
+	bt_mesh_search_nexthop_valid_with_cb(entry->source_address,entry->net_idx,callback);
+	/*Loop ends*/
+
+	/*	loop over the RERR list and send each entry	*/
+	struct rerr_list_entry* rerr_rx_entry=NULL;
+	k_sem_take(&rerr_list_sem, K_FOREVER);
+	while(!is_empty_rerr())
+	{
+		SYS_SLIST_FOR_EACH_CONTAINER(&rerr_list, rerr_rx_entry, node)
+		{ printk(" Sending RERR to nexthop %04x \n",rerr_rx_entry->next_hop);
+			rerr_send(rerr_rx_entry);
+			bt_mesh_delete_rerr_entry(rerr_rx_entry); //TODO?
+		}
+	}
+	k_sem_give(&rerr_list_sem);
+
+	/*delete Hello Error entry*/
+	//struct hello_msg_list_entry* hello_msg_entry=NULL;
+	k_sem_take(&hello_msg_list_sem, K_FOREVER);
+	//while(!is_empty_hello_msg_list())
+	//{
+		//SYS_SLIST_FOR_EACH_CONTAINER(&hello_msg_list, hello_msg_entry, node)
+		//{
+      bt_mesh_delete_hello_msg_entry(entry);
+			//bt_mesh_delete_hello_msg_entry(hello_msg_entry); //TODO?
+		//}
+	//}
+	k_sem_give(&hello_msg_list_sem);
+	view_valid_list();
+  view_invalid_list();
+  view_hello_msg_list();
+  view_rerr_list();
+	return; /*TODO*/
+
+}
+/*Reham*/
+void bt_mesh_delete_hello_msg_entry(struct hello_msg_list_entry *entry )
+{
+		k_sem_take(&hello_msg_list_sem, K_FOREVER);   							/* take semaphore */
+		sys_slist_find_and_remove(&hello_msg_list, &entry->node);   /*delete node from linked list */
+		k_sem_give(&hello_msg_list_sem);                            /*return semaphore */
+		k_mem_slab_free(&hello_msg_slab, (void **)&entry);  /*free space in slab*/
+}
+
+/* _TEST_*/
+// static void hello_publish(struct k_timer *timer_id)
+// {
+//  k_timer_start(&hello_send, HELLO_MSG_SEND, 0);
+//  u16_t feat = 0;
+//  struct __packed {
+//         u8_t  init_ttl;
+//         u16_t feat;
+//       } hb;
+//
+//   struct bt_mesh_msg_ctx ctx = {
+//     //.net_idx = entry_location->net_idx, //FIXME???
+//     .app_idx = BT_MESH_KEY_UNUSED,
+//     .addr = BT_MESH_ADDR_ALL_NODES,
+//     .send_ttl = 2,
+//   };
+//   struct bt_mesh_net_tx tx = {
+//   //  .sub = bt_mesh_subnet_get(entry_location->net_idx), //FIXME???
+//     .ctx = &ctx,
+//     .src = bt_mesh_primary_addr(),
+//     .xmit = bt_mesh_net_transmit_get(),
+//   };
+//
+//   hb.init_ttl = 2;
+//
+//    if (bt_mesh_relay_get() == BT_MESH_RELAY_ENABLED) {
+//      feat |= BT_MESH_FEAT_RELAY;
+//    }
+//
+//    if (bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_ENABLED) {
+//      feat |= BT_MESH_FEAT_PROXY;
+//    }
+//
+//    if (bt_mesh_friend_get() == BT_MESH_FRIEND_ENABLED) {
+//      feat |= BT_MESH_FEAT_FRIEND;
+//    }
+//
+//   #if defined(CONFIG_BT_MESH_LOW_POWER)
+//    if (bt_mesh.lpn.state != BT_MESH_LPN_DISABLED) {
+//      feat |= BT_MESH_FEAT_LOW_POWER;
+//    }
+//   #endif
+//
+//    hb.feat = sys_cpu_to_be16(feat);
+//
+//    BT_DBG("InitTTL %u feat 0x%04x", hb.init_ttl, feat);
+//    bt_mesh_ctl_send(&tx, TRANS_CTL_OP_HEARTBEAT, &hb, sizeof(hb),
+//         NULL, NULL, NULL);
+//
+// }
+/* _TEST_*/
+
+int hello_msg_list_create_entry(struct hello_msg_list_entry **entry_location)
+{
+
+	/*if space found in slab, Allocate new node */
+	if (k_mem_slab_alloc(&hello_msg_slab, (void **)&(*entry_location), 100) == 0)
+	{
+		memset((*entry_location), 0, HELLO_MSG_ENTRY_SIZE);                  /* Initializing with zeros */
+		k_sem_take(&hello_msg_list_sem, K_FOREVER);               /*take semaphore */
+		sys_slist_append(&hello_msg_list, &(*entry_location)->node); /*insert node in linkedlist */
+		k_sem_give(&hello_msg_list_sem);
+	}
+	else
+	{
+		printk("Memory Allocation timeout \n");
+		return false; //TODO : fix return
+	}
+
+	/* Start the lifetime timer */
+	k_timer_init (&(*entry_location)->lifetime, bt_mesh_delete_hello_msg_entry_timer, NULL);
+	k_timer_start(&(*entry_location)->lifetime, HELLO_MSG_LIFETIME, 0);
+  return true;//TODO :  fix return
+}
+
+
+
+int hello_msg_list_search_entry(u16_t src, struct hello_msg_list_entry **entry_data)
+{
+	struct hello_msg_list_entry *entry1 = NULL;
+	k_sem_take(&hello_msg_list_sem, K_FOREVER);
+	SYS_SLIST_FOR_EACH_CONTAINER(&hello_msg_list, entry1, node)
+	{
+		if (src==entry1->source_address)
+		{
+			k_sem_give(&hello_msg_list_sem);
+			*entry_data = entry1;
+			return true;//TODO: fix return
+		}
+
+	}
+	k_sem_give(&hello_msg_list_sem);
+	return false;	//TODO: fix return
+}
+
+
+void bt_mesh_trans_hello_msg_recv(u16_t src)
+{
+
+  	struct hello_msg_list_entry temp_entry;
+  	struct hello_msg_list_entry *entry = &temp_entry;
+	entry->source_address=src;
+    printk("hb source is: %04x",src);
+  	if (hello_msg_list_search_entry(src, &entry))
+  	{
+		k_timer_stop(&entry->lifetime);
+		//struct k_timer temp_timer;
+		//entry->lifetime = temp_timer;
+		//k_timer_init(&entry->lifetime,bt_mesh_delete_hello_msg_entry_timer, NULL);
+    BT_DBG("COOL.");
+
+		k_timer_start(&entry->lifetime, HELLO_MSG_LIFETIME, 0);
+
+  	}
+  	else
+  	{
+  		BT_DBG("Hello message receivd from a node not of interest.");
+  	}
+
+}
+
+void view_hello_msg_list()
+{
+	if (sys_slist_is_empty(&hello_msg_list)) {
+		printk("Hello Msg List is empty \n");
+		return;
+	}
+	struct hello_msg_list_entry *entry = NULL;
+	k_sem_take(&hello_msg_list_sem, K_FOREVER);
+	SYS_SLIST_FOR_EACH_CONTAINER(&hello_msg_list, entry, node){
+		printk("\x1b[32m Hello msg List:source address=%04x\x1b[0m \n", entry->source_address);
+		//printk("Valid List:hop count=%01x \n", entry->hop_count);
+
+	}
+	k_sem_give(&hello_msg_list_sem);
+}
+
+/* _RERR_ */
diff --git a/subsys/bluetooth/host/mesh/aodv_control_messages.h b/subsys/bluetooth/host/mesh/aodv_control_messages.h
index 31c02de..4c9b8dd 100755
--- a/subsys/bluetooth/host/mesh/aodv_control_messages.h
+++ b/subsys/bluetooth/host/mesh/aodv_control_messages.h
@@ -5,19 +5,14 @@
  *	The file contains RREQ, RREP and RWAIT data and functions.
  *  @bug No known bugs.
  */
-
- /* -- Includes -- */
-
 /* DEFINITIONS */
 /* RREQ DEFINITIONS */
-#define RREQ_SDU_MAX_SIZE 15
-#define RSSI_MIN -90
+#define RREQ_SDU_MAX_SIZE 14
 /* Macros used to dissect a buffer containing RREQ data*/
-#define RREQ_GET_SRC_ADDR(buf) buf->data[0] + (buf->data[1] << 8)
-#define RREQ_GET_DST_ADDR(buf) buf->data[2] + (buf->data[3] << 8)
-#define RREQ_GET_SRC_NUMBER_OF_ELEMENTS(buf) buf->data[4] + (buf->data[5] << 8)
-#define RREQ_GET_HOP_COUNT(buf) buf->data[6]
-#define RREQ_GET_RSSI(buf)  buf->data[7]
+#define RREQ_GET_SRC_ADDR(buf) buf->data[1] + (buf->data[2] << 8)
+#define RREQ_GET_DST_ADDR(buf) buf->data[3] + (buf->data[4] << 8)
+#define RREQ_GET_SRC_NUMBER_OF_ELEMENTS(buf) buf->data[5] + (buf->data[6] << 8)
+#define RREQ_GET_HOP_COUNT(buf) buf->data[7]
 #define RREQ_GET_G_FLAG(buf) (buf->data[8] & 0x01)
 #define RREQ_GET_D_FLAG(buf) (buf->data[8] & 0x02) >> 1
 #define RREQ_GET_U_FLAG(buf) (buf->data[8] & 0x04) >> 2
@@ -44,7 +39,24 @@
 #define RWAIT_GET_SRC_SEQ_NUM(buf) buf->data[5] + (buf->data[6] << 8) + (buf->data[7] << 16) + (buf->data[8] << 24)
 #define RWAIT_GET_HOP_COUNT(buf) buf->data[9]
 
+/* _RERR_ */
+/* RERR DEFINITIONS */
+#define RERR_GET_DST_NUM(buf) buf->data[0]
+#define RERR_GET_DST_ADDR(buf,i) (buf->data[i] + (buf->data[i+1] << 8))
+#define RERR_GET_DST_SEQ_NUM(buf,i) (buf->data[i+2] + (buf->data[i+3] << 8) + (buf->data[i+4] << 16))
+/* _RERR_ */
+
+/* _HELLO_*/
+
+/* Hello Message DEFINITIONS */
+#define HELLO_MSG_LIFETIME  K_SECONDS(20)
+//#define HELLO_MSG_SEND  K_SECONDS(5)
+
+/* _HELLO_*/
+
+
 /* DATA */
+//sys_slist_t rrep_rwait_list;
 
 /** @brief RREQ data for transmission or reception. Contains the transport layer
  *				 RREQ PDU and the network layer credentials.
@@ -59,7 +71,6 @@ struct rreq_data {
 			 U:1, 												 /* Unknown destination sequence number flag (1b)*/
 			 I:1; 									 			 /* Directed RREQ flag (1b)*/
 	u8_t hop_count; 									 /* Number of hops between RREQ originator and destination (1B) */
-	s8_t rssi;
 	u32_t source_sequence_number;			 /* RREQ originator sequence number (3B) */
 	u32_t destination_sequence_number; /* Last known sequence number of the RREQ destination (3B) */
 };
@@ -95,14 +106,55 @@ struct rreq_data {
 	sys_snode_t node;       					 /* Linkedlist node (4B) */
 };
 
+/* _RERR_ */
+/** @brief RERR data for transmission or reception. Contains the transport layer
+ *				 RERR PDU and the network layer credentials.
+ */
+
+ struct rerr_list_entry {
+	u8_t destination_number;
+	u16_t next_hop;
+	u16_t net_idx;
+ 	u16_t destination_address[10];      	 	/* RERR unreachable destination address (2B) */
+ 	u32_t destination_sequence_number[10]; 	/* RERR unreachable destination sequence number (3B) */
+	sys_snode_t node;       					 	/* Linkedlist node (4B) */
+};
+/* _RERR_ */
+
+/* _HELLO_ */
+
+/** @brief TODO: comment
+ */
+/*Reham*/
+ struct hello_msg_list_entry {
+	u16_t source_address;         /* Hello message source address (2B)*/
+ 	u16_t net_idx;
+	struct k_timer lifetime;        				/* Lifetime timer (52B) */
+	sys_snode_t node;      						 /* Linkedlist node (4B) */
+};
+/* _HELLO_ */
+
+
 /* FUNCTIONS PROTOTYPES */
 /* RREQ FUNCTIONS */
-int bt_mesh_trans_rreq_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf);
+bool bt_mesh_trans_rreq_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf);
 u8_t bt_mesh_trans_ring_search(struct bt_mesh_net_tx *tx);
 
 /* RREP FUNCTIONS */
-int bt_mesh_trans_rrep_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf);
+bool bt_mesh_trans_rrep_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf);
 void bt_mesh_trans_rrep_rwait_list_init();
 
 /* RWAIT FUNCTIONS */
 void bt_mesh_trans_rwait_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf);
+
+/* _RERR_ */
+/*RERR FUNCTIONS*/
+bool bt_mesh_trans_rerr_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf);
+void bt_mesh_trans_rerr_list_init();
+void bt_mesh_trans_rrep_rwait_list_init();
+//void callback(struct bt_mesh_route_entry *entry1);//FIXME
+//bool is_empty_rerr(); //FIXME
+/* _RERR_ */
+int hello_msg_list_create_entry(struct hello_msg_list_entry **entry_location);
+void view_hello_msg_list();
+void bt_mesh_trans_hello_msg_recv(u16_t src);
diff --git a/subsys/bluetooth/host/mesh/beacon.c b/subsys/bluetooth/host/mesh/beacon.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/beacon.h b/subsys/bluetooth/host/mesh/beacon.h
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/cfg_cli.c b/subsys/bluetooth/host/mesh/cfg_cli.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/cfg_srv.c b/subsys/bluetooth/host/mesh/cfg_srv.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/crypto.c b/subsys/bluetooth/host/mesh/crypto.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/crypto.h b/subsys/bluetooth/host/mesh/crypto.h
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/foundation.h b/subsys/bluetooth/host/mesh/foundation.h
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/friend.c b/subsys/bluetooth/host/mesh/friend.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/friend.h b/subsys/bluetooth/host/mesh/friend.h
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/health_cli.c b/subsys/bluetooth/host/mesh/health_cli.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/health_srv.c b/subsys/bluetooth/host/mesh/health_srv.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/lpn.c b/subsys/bluetooth/host/mesh/lpn.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/lpn.h b/subsys/bluetooth/host/mesh/lpn.h
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/main.c b/subsys/bluetooth/host/mesh/main.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/mesh.h b/subsys/bluetooth/host/mesh/mesh.h
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/net.c b/subsys/bluetooth/host/mesh/net.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/net.h b/subsys/bluetooth/host/mesh/net.h
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/prov.c b/subsys/bluetooth/host/mesh/prov.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/prov.h b/subsys/bluetooth/host/mesh/prov.h
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/proxy.c b/subsys/bluetooth/host/mesh/proxy.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/proxy.h b/subsys/bluetooth/host/mesh/proxy.h
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/routing_table.c b/subsys/bluetooth/host/mesh/routing_table.c
index 8fe6395..1d42cd4 100755
--- a/subsys/bluetooth/host/mesh/routing_table.c
+++ b/subsys/bluetooth/host/mesh/routing_table.c
@@ -5,19 +5,9 @@
  */
 
 /* -- Includes -- */
-#include <stdint.h>
 #include <zephyr.h>
-#include <misc/byteorder.h>
-#include <net/buf.h>
-#include <bluetooth/bluetooth.h>
-#include <bluetooth/mesh.h>
-#include "common/log.h"
-#include "adv.h"
-#include "mesh.h"
-#include "net.h"
-#include "transport.h"
-#include "access.h"
-#include "foundation.h"
+#include <misc/slist.h>
+#include <string.h>
 #include "routing_table.h"
 
 /** @brief Linked list holding pointers to the valid entries of the routing tables. */
@@ -25,6 +15,7 @@ sys_slist_t valid_list;
 /** @brief Linked list holding pointers to the invalid entries of the routing tables. */
 sys_slist_t invalid_list;
 
+
 K_SEM_DEFINE(valid_list_sem, 1, 1); 	/* Binary semaphore for valid list */
 K_SEM_DEFINE(invalid_list_sem, 1, 1); /* Binary semaphore for invalid list */
 struct k_mem_slab routing_table_slab; /* Memory slab for all entries */
@@ -49,25 +40,25 @@ void bt_mesh_routing_table_init()
  *
  *	@return True when allocation succeeds, False when no space is available.
  */
- bool bt_mesh_create_entry_valid(struct bt_mesh_route_entry **entry_location)
- {
- 	/* if space found in slab, Allocate new node */
- 	if (k_mem_slab_alloc(&routing_table_slab, (void **)&(*entry_location), ALLOCATION_INTERVAL) == 0) {
- 		memset((*entry_location), 0, ENTRY_SIZE);                  /* Initializing with zeros */
- 		k_sem_take(&valid_list_sem, K_FOREVER);                 /*take semaphore */
- 		sys_slist_append(&valid_list, &(*entry_location)->node);   /*insert node in linkedlist */
- 		k_sem_give(&valid_list_sem);
- 	} else    {
- 		printk("Memory Allocation timeout \n");
- 		return false;
- 	}
-
-
- 	/* Start the lifetime timer */
- 	k_timer_init (&(*entry_location)->lifetime, bt_mesh_delete_entry_valid, NULL);
- 	k_timer_start(&(*entry_location)->lifetime, LIFETIME, 0);
- 	return true;
- }
+bool bt_mesh_create_entry_valid(struct bt_mesh_route_entry **entry_location)
+{
+	/* if space found in slab, Allocate new node */
+	if (k_mem_slab_alloc(&routing_table_slab, (void **)&(*entry_location), ALLOCATION_INTERVAL) == 0) {
+		memset((*entry_location), 0, ENTRY_SIZE);                  /* Initializing with zeros */
+		k_sem_take(&valid_list_sem, K_FOREVER);                 /*take semaphore */
+		sys_slist_append(&valid_list, &(*entry_location)->node);   /*insert node in linkedlist */
+		k_sem_give(&valid_list_sem);
+	} else    {
+		printk("Memory Allocation timeout \n");
+		return false;
+	}
+
+
+	/* Start the lifetime timer */
+	k_timer_init (&(*entry_location)->lifetime, bt_mesh_delete_entry_valid, NULL);
+	k_timer_start(&(*entry_location)->lifetime, LIFETIME, 0);
+	return true;
+}
 
 /**
  *	@brief Create entry in the invalid list.
@@ -77,24 +68,24 @@ void bt_mesh_routing_table_init()
  *
  *	@return True when allocation succeeds, False when no space is available.
  */
- bool bt_mesh_create_entry_invalid(struct bt_mesh_route_entry **entry_location)
- {
- 	/*if space found in slab, Allocate new node */
- 	if (k_mem_slab_alloc(&routing_table_slab, (void **)&(*entry_location), ALLOCATION_INTERVAL) == 0) {
- 		memset((*entry_location), 0, ENTRY_SIZE);                  /* Initializing with zeros */
- 		k_sem_take(&invalid_list_sem, K_FOREVER);               /*take semaphore */
- 		sys_slist_append(&invalid_list, &(*entry_location)->node); /*insert node in linkedlist */
- 		k_sem_give(&invalid_list_sem);
- 	} else    {
- 		printk("Memory Allocation timeout \n");
- 		return false;
- 	}
-
- 	/* Start the lifetime timer */
- 	k_timer_init (&(*entry_location)->lifetime, bt_mesh_delete_entry_invalid, NULL);
- 	k_timer_start(&(*entry_location)->lifetime, LIFETIME, 0);
- 	return true;
- }
+bool bt_mesh_create_entry_invalid(struct bt_mesh_route_entry **entry_location)
+{
+	/*if space found in slab, Allocate new node */
+	if (k_mem_slab_alloc(&routing_table_slab, (void **)&(*entry_location), ALLOCATION_INTERVAL) == 0) {
+		memset((*entry_location), 0, ENTRY_SIZE);                  /* Initializing with zeros */
+		k_sem_take(&invalid_list_sem, K_FOREVER);               /*take semaphore */
+		sys_slist_append(&invalid_list, &(*entry_location)->node); /*insert node in linkedlist */
+		k_sem_give(&invalid_list_sem);
+	} else    {
+		printk("Memory Allocation timeout \n");
+		return false;
+	}
+
+	/* Start the lifetime timer */
+	k_timer_init (&(*entry_location)->lifetime, bt_mesh_delete_entry_invalid, NULL);
+	k_timer_start(&(*entry_location)->lifetime, LIFETIME, 0);
+	return true;
+}
 
 /**
  *	@brief Create entry in the invalid list.
@@ -105,25 +96,25 @@ void bt_mesh_routing_table_init()
  *
  *	@return True when allocation succeeds, False when no space is available.
  */
- bool bt_mesh_create_entry_invalid_with_cb(struct bt_mesh_route_entry **entry_location, \
- 				  void (*timer_cb)(struct k_timer *timer_id))
- {
-
- 	/* if space found in slab, Allocate new node */
- 	if (k_mem_slab_alloc(&routing_table_slab, (void **)&(*entry_location), ALLOCATION_INTERVAL) == 0) {
- 		memset(*(entry_location), 0, ENTRY_SIZE);                  /* Initializing with zeros */
- 		k_sem_take(&invalid_list_sem, K_FOREVER);               /*take semaphore */
- 		sys_slist_append(&invalid_list, &(*entry_location)->node); /*insert node in linkedlist */
- 		k_sem_give(&invalid_list_sem);
- 	} else    {
- 		printk("Memory Allocation timeout \n");
- 		return false;
- 	}
- 	/* Start the lifetime timer */
- 	k_timer_init (&(*entry_location)->lifetime, timer_cb, NULL);
- 	k_timer_start(&(*entry_location)->lifetime, RREQ_INTERVAL_WAIT, 0);
- 	return true;
- }
+bool bt_mesh_create_entry_invalid_with_cb(struct bt_mesh_route_entry **entry_location, \
+				  void (*timer_cb)(struct k_timer *timer_id))
+{
+
+	/* if space found in slab, Allocate new node */
+	if (k_mem_slab_alloc(&routing_table_slab, (void **)&(*entry_location), ALLOCATION_INTERVAL) == 0) {
+		memset(*(entry_location), 0, ENTRY_SIZE);                  /* Initializing with zeros */
+		k_sem_take(&invalid_list_sem, K_FOREVER);               /*take semaphore */
+		sys_slist_append(&invalid_list, &(*entry_location)->node); /*insert node in linkedlist */
+		k_sem_give(&invalid_list_sem);
+	} else    {
+		printk("Memory Allocation timeout \n");
+		return false;
+	}
+	/* Start the lifetime timer */
+	k_timer_init (&(*entry_location)->lifetime, timer_cb, NULL);
+	k_timer_start(&(*entry_location)->lifetime, RREQ_INTERVAL_WAIT, 0);
+	return true;
+}
 
 
 /* Search Entry Functions */
@@ -151,7 +142,7 @@ bool bt_mesh_search_valid_destination(u16_t source_address, u16_t destination_ad
 		    (source_address >= entry1->source_address) &&
 		    (source_address < (entry1->source_address + entry1->source_number_of_elements))) {
 			k_sem_give(&valid_list_sem);
-			*entry = entry1;
+			*entry = entry1; //FIXME entry and entry1 might later point to a deleted entries by another thread
 			return true;
 		}
 
@@ -413,7 +404,7 @@ bool bt_mesh_search_invalid_source_with_range(u16_t source_address, u16_t destin
 	struct bt_mesh_route_entry *entry1 = NULL;
 
 	k_sem_take(&invalid_list_sem, K_FOREVER); /*take semaphore */
-	SYS_SLIST_FOR_EACH_CONTAINER(&valid_list, entry1, node){ //FIXME
+	SYS_SLIST_FOR_EACH_CONTAINER(&invalid_list, entry1, node){
 		if ((entry1->source_address >= source_address) &&
 		    (entry1->source_address < (source_address + source_number_of_elements)) &&
 		    (destination_address == entry1->destination_address)) {
@@ -436,6 +427,7 @@ bool bt_mesh_search_invalid_source_with_range(u16_t source_address, u16_t destin
  */
 void bt_mesh_delete_entry_valid(struct k_timer *timer_id)
 {
+
 	/* container of timer_id to be deleted*/
 	struct bt_mesh_route_entry *entry = CONTAINER_OF(timer_id, struct bt_mesh_route_entry, lifetime);
 	k_sem_take(&valid_list_sem, K_FOREVER);   							/* take semaphore */
@@ -509,7 +501,7 @@ void bt_mesh_refresh_lifetime_invalid(struct bt_mesh_route_entry *entry)
 */
 bool bt_mesh_validate_route(struct bt_mesh_route_entry *entry)
 {
-		if (entry == NULL )
+		if (entry == false )
 		{
 		 return false;
 		}
@@ -530,7 +522,6 @@ bool bt_mesh_validate_route(struct bt_mesh_route_entry *entry)
 		return true;
 }
 
-
 /**
 *	@brief Inalidate route having passed source and destination addresses
 *
@@ -541,7 +532,7 @@ bool bt_mesh_validate_route(struct bt_mesh_route_entry *entry)
 */
 bool bt_mesh_invalidate_route(struct bt_mesh_route_entry *entry)
 {
-	 	if (entry == NULL )
+	 	if (entry == false )
 	 	{
 		 return false;
 	 	}
@@ -564,7 +555,8 @@ bool bt_mesh_invalidate_route(struct bt_mesh_route_entry *entry)
 
 
 /* Test Functions */
-/*void view_valid_list()
+
+void view_valid_list()
 {
 	if (sys_slist_is_empty(&valid_list)) {
 		printk("Valid List is empty \n");
@@ -573,8 +565,8 @@ bool bt_mesh_invalidate_route(struct bt_mesh_route_entry *entry)
 	struct bt_mesh_route_entry *entry = NULL;
 	k_sem_take(&valid_list_sem, K_FOREVER);
 	SYS_SLIST_FOR_EACH_CONTAINER(&valid_list, entry, node){
-		printk("Valid List:source address=%04x,destination address=%04x \n", entry->source_address, entry->destination_address);
-		printk("Valid List:hop count=%01x \n", entry->hop_count);
+		printk("\x1b[32mValid List:source address=%04x,destination address=%04x,nexthop address=%04x\x1b[0m \n", entry->source_address, entry->destination_address,entry->next_hop);
+		//printk("Valid List:hop count=%01x \n", entry->hop_count);
 
 	}
 	k_sem_give(&valid_list_sem);
@@ -589,8 +581,80 @@ void view_invalid_list()
 	struct bt_mesh_route_entry *entry = NULL;
 	k_sem_take(&invalid_list_sem, K_FOREVER);
 	SYS_SLIST_FOR_EACH_CONTAINER(&invalid_list, entry, node){
-		printk("Invalid List:source address=%04x,destination address=%04x \n", entry->source_address, entry->destination_address);
+		printk("\x1b[31mInvalid List:source address=%04x,destination address=%04x\x1b[0m\n", entry->source_address, entry->destination_address);
 	}
 	k_sem_give(&invalid_list_sem);
 }
-*/
+
+/* _RERR_ */
+
+void bt_mesh_search_valid_with_cb(u16_t destination_address, u16_t next_hop, u16_t net_idx,
+	 void (*cb)(struct bt_mesh_route_entry *))
+{	struct bt_mesh_route_entry *entry1=NULL;
+	k_sem_take(&valid_list_sem, K_FOREVER);
+	/*loop over the routing table with the given destination and */
+	SYS_SLIST_FOR_EACH_CONTAINER(&valid_list, entry1, node)
+	{
+		if ((destination_address == entry1->destination_address) && (next_hop==entry1->next_hop) && (net_idx==entry1->net_idx))
+			{						k_sem_give(&valid_list_sem);
+							  	cb(entry1);
+									k_sem_take(&valid_list_sem, K_FOREVER);
+			}
+	}
+						k_sem_give(&valid_list_sem);
+}
+
+bool bt_mesh_search_valid_destination_with_idx(u16_t source_address, u16_t destination_address,u16_t net_idx, struct bt_mesh_route_entry **entry)
+{
+	struct bt_mesh_route_entry *entry1 = NULL;
+	k_sem_take(&valid_list_sem, K_FOREVER);
+	SYS_SLIST_FOR_EACH_CONTAINER(&valid_list, entry1, node){
+		/* Search for the destination and source addresses in their range of elements */
+		if ((destination_address == entry1->destination_address) &&
+		    (source_address == entry1->source_address) &&
+		    (net_idx ==entry1->net_idx )) {
+			k_sem_give(&valid_list_sem);
+			*entry = entry1; //FIXME entry and entry1 might later point to a deleted entries by another thread
+			return true;
+		}
+	}
+	k_sem_give(&valid_list_sem);
+	return false;
+}
+
+
+bool bt_mesh_search_next_hop_with_net_idx(u16_t next_hop_address, u16_t net_idx, struct bt_mesh_route_entry **entry)
+{
+	struct bt_mesh_route_entry *entry1 = NULL;
+
+	k_sem_take(&valid_list_sem, K_FOREVER); /*take semaphore */
+	SYS_SLIST_FOR_EACH_CONTAINER(&valid_list, entry1, node)
+	{
+		if ((entry1->next_hop == next_hop_address) && (entry1->net_idx == net_idx))
+		{
+			k_sem_give(&valid_list_sem);
+			*entry = entry1;
+			return true;
+		}
+	}
+	k_sem_give(&invalid_list_sem);
+	return false;
+}
+
+void bt_mesh_search_nexthop_valid_with_cb(u16_t nexthop, u16_t net_idx,
+	 void (*cb)(struct bt_mesh_route_entry *))
+	 {	struct bt_mesh_route_entry *entry1=NULL;
+	k_sem_take(&valid_list_sem, K_FOREVER);
+	/*loop over the routing table with the given destination and */
+	SYS_SLIST_FOR_EACH_CONTAINER(&valid_list, entry1, node)
+	{	/* Search for the destination and source addresses in their range of elements */
+		if ((nexthop == entry1->next_hop) && (net_idx==entry1->net_idx))
+		{
+			k_sem_give(&valid_list_sem);
+		  	cb(entry1);
+			k_sem_take(&valid_list_sem, K_FOREVER);
+		}
+	}
+	k_sem_give(&valid_list_sem);
+}
+/* _RERR_ */
diff --git a/subsys/bluetooth/host/mesh/routing_table.h b/subsys/bluetooth/host/mesh/routing_table.h
index 8402c88..731785d 100755
--- a/subsys/bluetooth/host/mesh/routing_table.h
+++ b/subsys/bluetooth/host/mesh/routing_table.h
@@ -23,7 +23,6 @@ struct bt_mesh_route_entry {
 	u16_t source_number_of_elements;				/* Source number of elements (2B) */
 	u16_t destination_number_of_elements;		/* Destination number of elements (2B) */
 	u8_t hop_count;                 				/* Number of hops (1B) */
-	s8_t rssi;															/* Average RSSI (1B) */
 	bool repairable;												/* Repairable Flag (1B) */
 	u16_t net_idx;													/* Network Index (2B) */
 	struct k_timer lifetime;        				/* Lifetime timer (52B) */
diff --git a/subsys/bluetooth/host/mesh/shell.c b/subsys/bluetooth/host/mesh/shell.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/test.c b/subsys/bluetooth/host/mesh/test.c
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/test.h b/subsys/bluetooth/host/mesh/test.h
old mode 100755
new mode 100644
diff --git a/subsys/bluetooth/host/mesh/transport.c b/subsys/bluetooth/host/mesh/transport.c
index a2123e1..2d85a31 100755
--- a/subsys/bluetooth/host/mesh/transport.c
+++ b/subsys/bluetooth/host/mesh/transport.c
@@ -35,7 +35,6 @@
 
 // Surround with configuration parameter
 #include "aodv_control_messages.h"
-#include "routing_table.h"
 
 #define AID_MASK                    ((u8_t)(BIT_MASK(6)))
 
@@ -113,7 +112,7 @@ void bt_mesh_set_hb_sub_dst(u16_t addr)
 	hb_sub_dst = addr;
 }
 
-static int send_unseg(struct bt_mesh_net_tx *tx, struct net_buf_simple *sdu,
+int send_unseg(struct bt_mesh_net_tx *tx, struct net_buf_simple *sdu,
 		      const struct bt_mesh_send_cb *cb, void *cb_data)
 {
 	struct net_buf *buf;
@@ -448,26 +447,19 @@ struct bt_mesh_app_key *bt_mesh_app_key_find(u16_t app_idx)
 int bt_mesh_trans_send(struct bt_mesh_net_tx *tx, struct net_buf_simple *msg,
 		       const struct bt_mesh_send_cb *cb, void *cb_data)
 {
-	const u8_t *key;
+	const u8_t *key=NULL;
 	u8_t *ad;
 	int err;
 	if(!bt_mesh_elem_find(tx->ctx->addr) ){
-		struct bt_mesh_route_entry *entry=NULL;
-		if(bt_mesh_search_valid_destination(bt_mesh_primary_addr(),tx->ctx->addr,&entry)){
-			printk("Destination Found\n");
-	}
-	else{
-	printk("Initiating Ring Search\n");
-	err=bt_mesh_trans_ring_search(tx);
-	if(!err){
-		return 0;
-	}
-	else
-	{
-		BT_ERR("Destination not found\n");
-		return err;
-	}
-	}
+		err=bt_mesh_trans_ring_search(tx);
+		if(!err){
+			return 0;
+		}
+		else
+		{
+			BT_ERR("Destination not found\n");
+			return err;
+		}
 	}
 
 	if (net_buf_simple_tailroom(msg) < 4) {
@@ -486,14 +478,13 @@ int bt_mesh_trans_send(struct bt_mesh_net_tx *tx, struct net_buf_simple *msg,
 	if (tx->ctx->app_idx == BT_MESH_KEY_DEV) {
 		key = bt_mesh.dev_key;
 		tx->aid = 0;
-	} else {
+	}
+	else if(tx->ctx->app_idx != BT_MESH_KEY_UNUSED){
 		struct bt_mesh_app_key *app_key;
-
 		app_key = bt_mesh_app_key_find(tx->ctx->app_idx);
 		if (!app_key) {
 			return -EINVAL;
 		}
-
 		if (tx->sub->kr_phase == BT_MESH_KR_PHASE_2 &&
 		    app_key->updated) {
 			key = app_key->keys[1].val;
@@ -515,22 +506,24 @@ int bt_mesh_trans_send(struct bt_mesh_net_tx *tx, struct net_buf_simple *msg,
 	} else {
 		ad = NULL;
 	}
-
-	err = bt_mesh_app_encrypt(key, tx->ctx->app_idx == BT_MESH_KEY_DEV,
-				  tx->aszmic, msg, ad, tx->src,
-				  tx->ctx->addr, bt_mesh.seq,
-				  BT_MESH_NET_IVI_TX);
+	if(tx->ctx->app_idx != BT_MESH_KEY_UNUSED){
+		err = bt_mesh_app_encrypt(key, tx->ctx->app_idx == BT_MESH_KEY_DEV,
+						tx->aszmic, msg, ad, tx->src,
+						tx->ctx->addr, bt_mesh.seq,
+						BT_MESH_NET_IVI_TX);
 	if (err) {
 		return err;
 	}
 
+	}
+
 	if (tx->ctx->send_rel) {
 		err = send_seg(tx, msg, cb, cb_data);
 	} else {
 		err = send_unseg(tx, msg, cb, cb_data);
 	}
 
-return err;
+	return err;
 }
 
 int bt_mesh_trans_resend(struct bt_mesh_net_tx *tx, struct net_buf_simple *msg,
@@ -800,6 +793,7 @@ static int trans_heartbeat(struct bt_mesh_net_rx *rx,
 	       (hops == 1) ? "" : "s", feat);
 
 	bt_mesh_heartbeat(rx->ctx.addr, rx->dst, hops, feat);
+	bt_mesh_trans_hello_msg_recv(rx->ctx.addr);
 
 	return 0;
 }
@@ -831,6 +825,8 @@ static int ctl_recv(struct bt_mesh_net_rx *rx, u8_t hdr,
 		case TRANS_CTL_OP_RWAIT:
 		 	bt_mesh_trans_rwait_recv(rx,buf);
 			return 0;
+		case TRANS_CTL_OP_RERR:
+			return bt_mesh_trans_rerr_recv(rx,buf);
 		}
 	}
 	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && !bt_mesh_lpn_established()) {
@@ -973,7 +969,8 @@ int bt_mesh_ctl_send(struct bt_mesh_net_tx *tx, u8_t ctl_op, void *data,
 			return 0;
 		}
 	}
-	return bt_mesh_net_send(tx, buf, cb, cb_data);
+	u8_t x=bt_mesh_net_send(tx, buf, cb, cb_data);
+	return x;
 }
  else
 	{
@@ -999,6 +996,7 @@ int bt_mesh_ctl_send(struct bt_mesh_net_tx *tx, u8_t ctl_op, void *data,
 		tx_seg->dst = tx->ctx->addr;
 		tx_seg->seg_n = segment_count;
 		tx_seg->nack_count = tx_seg->seg_n + 1;
+		//tx_seg->nack_count = 0;
 		tx_seg->seq_auth = SEQ_AUTH(BT_MESH_NET_IVI_TX, bt_mesh.seq);
 		tx_seg->sub = tx->sub;
 		tx_seg->new_key = tx->sub->kr_flag;
@@ -1544,7 +1542,7 @@ void bt_mesh_trans_init(void)
 				       (i * CONFIG_BT_MESH_RX_SDU_MAX));
 		seg_rx[i].buf.data = seg_rx[i].buf.__buf;
 	}
-	bt_mesh_routing_table_init();
+
 	bt_mesh_trans_rrep_rwait_list_init(); /* Initialize the rrep_list */
 }
 
diff --git a/subsys/bluetooth/host/mesh/transport.h b/subsys/bluetooth/host/mesh/transport.h
old mode 100755
new mode 100644
index ad8d21b..0b51143
--- a/subsys/bluetooth/host/mesh/transport.h
+++ b/subsys/bluetooth/host/mesh/transport.h
@@ -27,9 +27,10 @@
 #define TRANS_CTL_OP_FRIEND_SUB_CFM    0x09
 #define TRANS_CTL_OP_HEARTBEAT         0x0a
 
-#define TRANS_CTL_OP_RREQ 						 0x0b
-#define TRANS_CTL_OP_RREP							 0x0c
-#define TRANS_CTL_OP_RWAIT						 0x0d
+#define TRANS_CTL_OP_RREQ 				0x0b
+#define TRANS_CTL_OP_RREP				0x0c
+#define TRANS_CTL_OP_RWAIT				0x0d
+#define TRANS_CTL_OP_RERR				0x0e
 
 struct bt_mesh_ctl_friend_poll {
 	u8_t  fsn;
